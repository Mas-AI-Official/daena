{% extends "base.html" %}

{% block title %}Brain & API Settings - Daena VP{% endblock %}

{% block head %}
<style>
    .brain-container {
        padding: 24px;
        max-width: 1400px;
        margin: 0 auto;
    }

    .page-header {
        margin-bottom: 24px;
    }

    .page-header h1 {
        font-size: 26px;
        font-weight: 700;
        color: white;
        margin-bottom: 6px;
    }

    .page-header p {
        color: #9CA3AF;
        font-size: 14px;
    }

    /* Routing Mode dropdown - modern look */
    .routing-mode-wrap {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.05);
        padding: 8px 14px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        min-width: 200px;
    }

    .routing-mode-wrap:focus-within {
        border-color: var(--daena-gold);
        box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
    }

    .routing-mode-wrap label {
        font-size: 13px;
        color: #9CA3AF;
        white-space: nowrap;
    }

    .routing-mode-select {
        flex: 1;
        padding: 6px 28px 6px 10px;
        background: rgba(0, 0, 0, 0.25);
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239CA3AF' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
    }

    .routing-mode-select option {
        background: #1a1a1a;
        color: white;
    }

    .routing-mode-select:focus {
        outline: none;
    }

    .scan-btn {
        padding: 10px 20px;
        background: var(--daena-gold);
        color: black;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        border: none;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .header-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
    }

    /* Section Cards */
    .section-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        margin-bottom: 24px;
        overflow: hidden;
    }

    .section-header {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .section-icon {
        width: 40px;
        height: 40px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        color: white;
    }

    .section-title {
        font-size: 16px;
        font-weight: 700;
        color: white;
    }

    .section-body {
        padding: 16px 20px;
    }

    /* Model Cards - compact for 8 Ollama boxes */
    .models-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 10px;
    }

    .model-card {
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 10px;
        transition: all 0.3s ease;
    }

    .model-card:hover {
        border-color: rgba(212, 175, 55, 0.3);
    }

    .model-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .model-name {
        font-size: 14px;
        font-weight: 600;
        color: white;
    }

    .model-status {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 11px;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }

    .status-dot.online {
        background: #32CD32;
        box-shadow: 0 0 6px #32CD32;
    }

    .status-dot.offline {
        background: #FF6464;
    }

    .status-dot.checking {
        background: #FFA500;
        animation: pulse 1s infinite;
    }

    .model-details {
        font-size: 11px;
        color: #9CA3AF;
        margin-bottom: 6px;
    }

    .model-stats {
        display: flex;
        gap: 10px;
        margin-bottom: 6px;
        padding-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-item {
        text-align: center;
    }

    .stat-value {
        font-size: 13px;
        font-weight: 700;
        color: white;
    }

    .stat-label {
        font-size: 9px;
        color: #9CA3AF;
    }

    /* Toggle */
    .toggle {
        position: relative;
        width: 44px;
        height: 24px;
    }

    .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .toggle-slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 24px;
        transition: 0.3s;
    }

    .toggle-slider::before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background: white;
        border-radius: 50%;
        transition: 0.3s;
    }

    input:checked+.toggle-slider {
        background: var(--daena-gold);
    }

    input:checked+.toggle-slider::before {
        transform: translateX(20px);
    }

    /* API Key Input */
    .api-row {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .api-row:last-child {
        border-bottom: none;
    }

    .api-icon {
        width: 36px;
        height: 36px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        color: white;
    }

    .api-info {
        flex: 1;
    }

    .api-name {
        font-size: 14px;
        font-weight: 600;
        color: white;
    }

    .api-status {
        font-size: 11px;
        color: #9CA3AF;
    }

    .api-key-input {
        width: 200px;
        padding: 8px 12px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 12px;
    }

    .api-key-input:focus {
        outline: none;
        border-color: var(--daena-gold);
    }

    /* Usage Stats */
    .usage-bar {
        height: 6px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 8px;
    }

    .usage-fill {
        height: 100%;
        border-radius: 3px;
        transition: width 0.5s ease;
    }

    @keyframes pulse {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.5;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="brain-container">
    <div class="page-header">
        <h1>Brain & API Settings</h1>
        <p>Manage local LLM models and cloud API connections</p>
    </div>
    <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
        <div class="routing-mode-wrap">
            <label for="routing-mode">Routing Mode:</label>
            <select id="routing-mode" class="routing-mode-select" onchange="setRoutingMode(this.value)"
                aria-label="Routing mode">
                <option value="local_only">Local Only (Offline)</option>
                <option value="hybrid">Hybrid (Smart)</option>
                <option value="api_only">API Only (Cloud)</option>
            </select>
        </div>
        <button class="scan-btn" onclick="scanModels()">
            <i class="fas fa-sync-alt"></i> Scan Local Models
        </button>
    </div>
</div>

<!-- Offline models location: editable, syncs to backend -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(50, 205, 50, 0.2); color: #32CD32;">
            <i class="fas fa-folder-open"></i>
        </div>
        <div class="section-title">Offline models location</div>
    </div>
    <div class="section-body">
        <div class="flex items-center gap-3 flex-wrap">
            <label class="text-[13px] text-gray-400">Path:</label>
            <input type="text" id="offline-path-input" class="api-key-input flex-1 min-w-[200px] max-w-xl"
                placeholder="e.g. D:\Ideas\MODELS_ROOT"
                title="Change offline root for LLMs; saves to backend. Edit and Save or press Enter."
                autocomplete="off" />
            <button type="button" id="offline-save-btn" class="scan-btn"
                style="padding: 6px 12px; font-size: 12px;">Save</button>
            <button type="button" id="offline-open-folder-btn" class="scan-btn"
                style="padding: 6px 12px; font-size: 12px; background: rgba(65, 105, 225, 0.3);"
                title="Open this folder in Explorer/Finder"><i class="fas fa-folder-open"></i> Open folder</button>
            <button type="button" id="offline-copy-btn" class="scan-btn"
                style="padding: 6px 12px; font-size: 12px; background: rgba(255,255,255,0.1);" title="Copy path"><i
                    class="fas fa-copy"></i> Copy</button>
        </div>
        <p class="text-[11px] text-gray-500 mt-2">Change the path and Save (or blur/Enter) to update the backend in real
            time. Local (Ollama) models are under this path/ollama. Use "Open folder" to browse and copy a path.</p>
    </div>
</div>

<!-- Autopilot (Daena setting) -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(212, 175, 55, 0.2); color: var(--daena-gold);">
            <i class="fas fa-robot"></i>
        </div>
        <div class="section-title">Autopilot</div>
    </div>
    <div class="section-body">
        <div class="flex items-center gap-3 flex-wrap">
            <label class="toggle">
                <input type="checkbox" id="autopilot-toggle" onchange="setAutopilot(this.checked)">
                <span class="toggle-slider"></span>
            </label>
            <span class="text-[13px] text-gray-300">Let Daena run tasks and routing automatically.</span>
        </div>
    </div>
</div>

<!-- Local Models Section -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(50, 205, 50, 0.2); color: #32CD32;">
            <i class="fas fa-brain"></i>
        </div>
        <div class="section-title">Local Models (Ollama)</div>
    </div>
    <div class="section-body">
        <div class="ollama-search-bar" style="justify-content: flex-end;">
            <button type="button" class="btn-refresh" onclick="scanModels()">
                <i class="fas fa-sync-alt"></i> Refresh
            </button>
        </div>
        <div class="models-grid" id="local-models">
            <!-- Loaded via JS -->
        </div>
    </div>
</div>

<!-- Trained Models Section -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(212, 175, 55, 0.2); color: var(--daena-gold);">
            <i class="fas fa-graduation-cap"></i>
        </div>
        <div class="section-title">Trained Daena Models</div>
    </div>
    <div class="section-body">
        <div class="models-grid" id="trained-models">
            <!-- Loaded via JS -->
        </div>
    </div>
</div>

<!-- Cloud LLM APIs: keys sync to backend stack -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(65, 105, 225, 0.2); color: #4169E1;">
            <i class="fas fa-cloud"></i>
        </div>
        <div class="section-title">Cloud LLM APIs</div>
    </div>
    <div class="section-body">
        <p class="text-[12px] text-gray-500 mb-3">Add API keys below; they sync to the backend stack. Toggle each
            provider on/off after saving a key.</p>
        <div id="cloud-apis">
            <!-- Loaded via JS -->
        </div>
    </div>
</div>

<!-- Usage Statistics -->
<div class="section-card">
    <div class="section-header">
        <div class="section-icon" style="background: rgba(147, 112, 219, 0.2); color: #9370DB;">
            <i class="fas fa-chart-pie"></i>
        </div>
        <div class="section-title">Usage Statistics (This Month)</div>
    </div>
    <div class="section-body">
        <div class="models-grid" id="usage-stats">
            <!-- Loaded via JS -->
        </div>
    </div>
</div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Removed mock data - now loading from APIs
    let localModelsData = [];
    let trainedModelsData = [];
    let cloudAPIs = [];
    let activeModel = null;  // Primary model (for backward compatibility)
    let activeModels = [];   // All active models (supports multiple)
    let usageStats = {};

    function renderLocalModels() {
        const container = document.getElementById('local-models');
        if (!container) return;

        if (localModelsData.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 40px; color: #9CA3AF;">No models found. Click "Scan Local Models" to refresh.</div>';
            return;
        }

        container.innerHTML = localModelsData.map(model => {
            const isActive = activeModels.includes(model.name) || model.name === activeModel;
            return `
        <div class="model-card" style="${isActive ? 'border-color: var(--daena-gold); background: rgba(212, 175, 55, 0.05);' : ''}">
            <div class="model-header">
                <div class="model-name" style="${isActive ? 'color: var(--daena-gold);' : ''}">
                    ${model.name} ${isActive ? '⭐' : ''}
                </div>
                <label class="toggle">
                    <input type="checkbox" ${isActive ? 'checked' : ''} 
                           onchange="selectModel('${model.name}', this.checked)">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="model-details">Size: ${model.size}</div>
            <div class="model-status">
                <div class="status-dot ${model.status}"></div>
                <span style="color: ${model.status === 'online' ? '#32CD32' : '#FF6464'}">${model.status.toUpperCase()}</span>
            </div>
            <div class="model-stats">
                <div class="stat-item">
                    <div class="stat-value">${model.calls.toLocaleString()}</div>
                    <div class="stat-label">API Calls</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${(model.tokens / 1000).toFixed(2)}k</div>
                    <div class="stat-label">Tokens</div>
                </div>
            </div>
            <div style="margin-top: 8px; display: flex; gap: 6px;">
                <button onclick="testModel('${model.name}')" style="flex: 1; padding: 5px 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: white; cursor: pointer; font-size: 10px;">
                    <i class="fas fa-vial"></i> Test
                </button>
                <button onclick="pullModel('${model.name}')" style="flex: 1; padding: 5px 8px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; color: white; cursor: pointer; font-size: 10px;">
                    <i class="fas fa-download"></i> Pull
                </button>
            </div>
        </div>
    `;
        }).join('');
    }

    function renderTrainedModels() {
        const container = document.getElementById('trained-models');
        container.innerHTML = trainedModelsData.map(model => `
        <div class="model-card">
            <div class="model-header">
                <div class="model-name" style="color: var(--daena-gold)">${model.name}</div>
                <label class="toggle">
                    <input type="checkbox" ${model.status === 'online' ? 'checked' : ''} 
                           onchange="toggleModel('${model.name}', this.checked)">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="model-details">Size: ${model.size} | Trained: ${model.trained}</div>
            <div class="model-status">
                <div class="status-dot ${model.status}"></div>
                <span style="color: ${model.status === 'online' ? '#32CD32' : '#FF6464'}">${model.status.toUpperCase()}</span>
            </div>
            <div class="model-stats">
                <div class="stat-item">
                    <div class="stat-value">${model.calls.toLocaleString()}</div>
                    <div class="stat-label">API Calls</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">${(model.tokens / 1000).toFixed(2)}k</div>
                    <div class="stat-label">Tokens</div>
                </div>
            </div>
        </div>
    `).join('');
    }

    function renderCloudAPIs() {
        const container = document.getElementById('cloud-apis');
        if (!container) return;
        container.innerHTML = cloudAPIs.map((api, idx) => `
        <div class="api-row">
            <div class="api-icon" style="background: ${api.color}33">
                <i class="fas ${api.icon}" style="color: ${api.color}"></i>
            </div>
            <div class="api-info">
                <div class="api-name">${api.name}</div>
                <div class="api-status">${api.hasKey ? `$${api.used.toFixed(2)} / $${api.credits.toFixed(2)} credits used` : 'No API key configured'}</div>
            </div>
            <input type="password" class="api-key-input" placeholder="Enter API Key..." 
                   id="api-key-${idx}" onchange="saveAPIKey(${idx}, this.value)">
            <button type="button" onclick="saveAPIKey(${idx}, document.getElementById('api-key-${idx}').value)" class="scan-btn" style="padding: 8px 14px; font-size: 12px;">Save</button>
            <label class="toggle">
                <input type="checkbox" id="cloud-toggle-${idx}" ${api.enabled ? 'checked' : ''} 
                       onchange="toggleCloud(${idx}, this.checked)">
                <span class="toggle-slider"></span>
            </label>
        </div>
    `).join('');
    }

    function showAddCloudApiModal() {
        const providerId = window.prompt('Provider ID (e.g. openai, anthropic, my-company):');
        if (providerId == null || !providerId.trim()) return;
        const key = window.prompt('API Key (optional – you can Save after adding):');
        if (key == null) return;
        addCloudApiAndSave(providerId.trim().toLowerCase().replace(/\s+/g, '-'), key.trim());
    }

    async function addCloudApiAndSave(providerId, key) {
        try {
            const r = await fetch(`/api/v1/brain/cloud/${encodeURIComponent(providerId)}/key`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: key || '' })
            });
            const data = await r.json().catch(() => ({}));
            if (data.success) {
                if (window.showToast) window.showToast('Cloud API added. Refreshing list.', 'success');
                await scanModels();
            } else {
                if (window.showToast) window.showToast(data.error || 'Failed to add provider', 'error');
            }
        } catch (e) {
            if (window.showToast) window.showToast('Request failed', 'error');
        }
    }

    function renderUsageStats() {
        const container = document.getElementById('usage-stats');
        if (!container) return;

        const totalCalls = localModelsData.reduce((a, m) => a + m.calls, 0) + trainedModelsData.reduce((a, m) => a + m.calls, 0);
        const totalTokens = localModelsData.reduce((a, m) => a + m.tokens, 0) + trainedModelsData.reduce((a, m) => a + m.tokens, 0);

        // Calculate local vs cloud (all local for now)
        const localPercentage = totalCalls > 0 ? 100 : 0;

        container.innerHTML = `
        <div class="model-card">
            <div class="model-name">Total API Calls</div>
            <div class="stat-value" style="font-size: 28px; margin: 12px 0;">${totalCalls.toLocaleString()}</div>
            <div class="usage-bar"><div class="usage-fill" style="width: ${Math.min(100, (totalCalls / 10000) * 100)}%; background: var(--daena-gold);"></div></div>
        </div>
        <div class="model-card">
            <div class="model-name">Total Tokens</div>
            <div class="stat-value" style="font-size: 28px; margin: 12px 0;">${(totalTokens / 1000000).toFixed(2)}M</div>
            <div class="usage-bar"><div class="usage-fill" style="width: ${Math.min(100, (totalTokens / 10000000) * 100)}%; background: #32CD32;"></div></div>
        </div>
        <div class="model-card">
            <div class="model-name">Local vs Cloud</div>
            <div class="stat-value" style="font-size: 28px; margin: 12px 0;">${localPercentage.toFixed(2)}% Local</div>
            <div class="usage-bar"><div class="usage-fill" style="width: ${localPercentage}%; background: #00CED1;"></div></div>
        </div>
    `;
    }

    async function scanModels() {
        const btn = document.querySelector('.scan-btn i');
        if (btn) btn.classList.add('fa-spin');

        try {
            // Run scan in background — don't block model list if scan fails (e.g. model_registry missing)
            fetch('/api/v1/brain/scan', { method: 'POST' }).catch(() => { });

            // Load models, status, usage from backend (Brain Status API)
            const [modelsResponse, statusResponse, usageResponse] = await Promise.all([
                fetch('/api/v1/brain/models'),
                fetch('/api/v1/brain/status'),
                fetch('/api/v1/brain/models/usage')
            ]);

            const modelsData = modelsResponse.ok ? await modelsResponse.json().catch(() => null) : null;
            const statusData = statusResponse.ok ? await statusResponse.json().catch(() => null) : null;
            const usageData = usageResponse.ok ? await usageResponse.json().catch(() => null) : null;

            usageStats = (usageData && usageData.stats) ? usageData.stats : {};

            // Load models from GET /api/v1/brain/models, or fallback to status.models or list-models
            if (modelsData) {
                localModelsData = (modelsData.local || []).map(m => ({
                    name: m.name,
                    size: `${m.size_gb != null ? m.size_gb : 0} GB`,
                    status: 'online',
                    calls: usageStats[m.name]?.calls || 0,
                    tokens: usageStats[m.name]?.tokens || 0
                }));
                trainedModelsData = (modelsData.trained || []).map(m => ({
                    name: m.name,
                    size: 'N/A',
                    status: 'offline',
                    calls: 0,
                    tokens: 0,
                    trained: 'N/A'
                }));
                cloudAPIs = (modelsData.cloud || []).map(api => ({
                    name: api.name.split('/')[1] || api.name,
                    provider: api.provider || api.name.split('/')[0]?.toLowerCase() || api.name.toLowerCase(),
                    icon: getCloudIcon(api.name),
                    color: getCloudColor(api.name),
                    status: api.status === 'configured' ? 'connected' : 'disconnected',
                    hasKey: api.status === 'configured',
                    enabled: !!api.enabled,
                    credits: 0,
                    used: 0
                }));
            } else if (statusData && (statusData.models && statusData.models.length)) {
                localModelsData = statusData.models.map(m => ({
                    name: (typeof m === 'object' && m.name) ? m.name : m,
                    size: (typeof m === 'object' && m.size != null) ? formatSize(m.size) : '—',
                    status: 'online',
                    calls: usageStats[(typeof m === 'object' && m.name) ? m.name : m]?.calls || 0,
                    tokens: usageStats[(typeof m === 'object' && m.name) ? m.name : m]?.tokens || 0
                }));
            } else {
                // Fallback: try GET /api/v1/brain/list-models
                try {
                    const listRes = await fetch('/api/v1/brain/list-models');
                    if (listRes.ok) {
                        const listData = await listRes.json();
                        const list = listData.models || [];
                        localModelsData = list.map(m => ({
                            name: (m && m.name) ? m.name : m,
                            size: (m && m.size != null) ? formatSize(m.size) : '—',
                            status: 'online',
                            calls: usageStats[(m && m.name) ? m.name : m]?.calls || 0,
                            tokens: usageStats[(m && m.name) ? m.name : m]?.tokens || 0
                        }));
                    }
                } catch (_) { }
            }

            // Load active models, routing mode, offline path (always when statusData exists)
            if (statusData) {
                activeModel = statusData.active_model;  // Primary (backward compatibility)
                activeModels = statusData.active_models || (activeModel ? [activeModel] : []);  // All active

                const routingSelect = document.getElementById('routing-mode');
                if (routingSelect && statusData.routing_mode) {
                    routingSelect.value = statusData.routing_mode;
                }

                const pathInput = document.getElementById('offline-path-input');
                const pathToShow = statusData.models_root || statusData.local_brain_path || '';
                if (pathInput) {
                    pathInput.value = pathToShow;
                    pathInput.placeholder = pathToShow || 'e.g. D:\\Ideas\\MODELS_ROOT';
                }
                window._offlineModelsPath = pathToShow;
            }

            // Merge usage into local model cards
            localModelsData = localModelsData.map(m => ({
                ...m,
                calls: usageStats[m.name]?.calls || 0,
                tokens: usageStats[m.name]?.tokens || 0
            }));

            renderLocalModels();
            renderTrainedModels();
            renderCloudAPIs();
            renderUsageStats();
        } catch (e) {
            console.error('Failed to scan models:', e);
            if (window.showToast) {
                window.showToast('Failed to load models. Check Ollama connection.', 'error');
            }
        }

        if (btn) btn.classList.remove('fa-spin');
    }

    async function setRoutingMode(mode) {
        try {
            const response = await fetch('/api/v1/brain/routing_mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: mode })
            });
            const data = await response.json();

            if (data.success) {
                if (window.showToast) window.showToast(`Routing mode set to: ${mode}`, 'success');
            } else {
                if (window.showToast) window.showToast(data.error || 'Failed to set routing mode', 'error');
                // Revert UI
                scanModels();
            }
        } catch (e) {
            console.error('Failed to set routing mode:', e);
            if (window.showToast) window.showToast('Failed to set routing mode', 'error');
        }
    }

    function getCloudIcon(name) {
        const icons = {
            'openai': 'fa-robot',
            'google': 'fa-google',
            'anthropic': 'fa-brain',
            'xai': 'fa-bolt',
            'deepseek': 'fa-search'
        };
        return icons[name.toLowerCase().split('/')[0]] || 'fa-cloud';
    }

    function getCloudColor(name) {
        const colors = {
            'openai': '#00A67E',
            'google': '#4285F4',
            'anthropic': '#D77B3F',
            'xai': '#1DA1F2',
            'deepseek': '#9370DB'
        };
        return colors[name.toLowerCase().split('/')[0]] || '#6B7280';
    }

    function formatSize(bytes) {
        const gb = bytes / (1024 * 1024 * 1024);
        return gb.toFixed(2) + ' GB';
    }

    async function selectModel(name, enabled) {
        try {
            // Support multiple active models - use enabled parameter
            const response = await fetch(`/api/v1/brain/models/${encodeURIComponent(name)}/select?enabled=${enabled}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            const data = await response.json();

            if (data.success) {
                // Update active models list
                if (data.active_models) {
                    activeModels = data.active_models;
                } else if (enabled) {
                    activeModels = [name];
                } else {
                    activeModels = activeModels.filter(m => m !== name);
                }

                renderLocalModels();
                if (window.showToast) {
                    window.showToast(data.message || `Model ${name} ${enabled ? 'enabled' : 'disabled'}`, 'success');
                }
            } else {
                if (window.showToast) {
                    window.showToast(data.error || 'Failed to toggle model', 'error');
                }
                renderLocalModels(); // Reset UI
            }
        } catch (e) {
            console.error('Failed to toggle model:', e);
            if (window.showToast) {
                window.showToast('Failed to toggle model', 'error');
            }
            renderLocalModels(); // Reset UI
        }
    }

    // Toggle model = select model (alias for consistency)
    async function toggleModel(name, enabled) {
        await selectModel(name, enabled);
    }

    async function testModel(name) {
        try {
            const response = await fetch('/api/v1/brain/test', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_name: name })
            });
            const data = await response.json();

            if (data.success) {
                if (window.showToast) {
                    window.showToast(`Model test successful: ${data.response}`, 'success');
                } else {
                    alert(`Model test successful: ${data.response}`);
                }
            } else {
                if (window.showToast) {
                    window.showToast(data.error || 'Model test failed', 'error');
                } else {
                    alert(`Model test failed: ${data.error}`);
                }
            }
        } catch (e) {
            console.error('Failed to test model:', e);
            if (window.showToast) {
                window.showToast('Failed to test model', 'error');
            }
        }
    }

    async function pullModel(name) {
        if (!confirm(`Download ${name}? This may take several minutes.`)) {
            return;
        }
        await doPull(name);
    }



    async function doPull(modelName) {
        try {
            const response = await fetch('/api/v1/brain/pull', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ model_name: modelName })
            });
            const data = await response.json();
            if (data.success) {
                if (window.showToast) window.showToast(`Started pulling ${modelName}. List will refresh in a few seconds.`, 'success');
            } else {
                if (window.showToast) window.showToast(data.error || 'Failed to pull model', 'error');
            }
        } catch (e) {
            console.error('Failed to pull model:', e);
            if (window.showToast) window.showToast('Failed to pull model', 'error');
        }
    }

    async function toggleCloud(idx, enabled) {
        const provider = cloudAPIs[idx].provider || cloudAPIs[idx].name.toLowerCase().split(/[/-]/)[0];
        try {
            const r = await fetch(`/api/v1/brain/cloud/${encodeURIComponent(provider)}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });
            const data = await r.json().catch(() => ({}));
            if (data.success) {
                cloudAPIs[idx].enabled = enabled;
                cloudAPIs[idx].status = enabled ? 'connected' : 'disconnected';
                if (window.showToast) window.showToast(enabled ? 'Cloud API enabled' : 'Cloud API disabled', 'success');
            } else {
                if (window.showToast) window.showToast(data.error || 'Failed to toggle', 'error');
                renderCloudAPIs();
                return;
            }
        } catch (e) {
            if (window.showToast) window.showToast('Request failed', 'error');
            renderCloudAPIs();
            return;
        }
        renderCloudAPIs();
    }

    async function saveAPIKey(idx, key) {
        const provider = cloudAPIs[idx].provider || cloudAPIs[idx].name.toLowerCase().split(/[/-]/)[0];
        const keyVal = (key || '').trim();
        try {
            const r = await fetch(`/api/v1/brain/cloud/${encodeURIComponent(provider)}/key`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: keyVal })
            });
            const data = await r.json().catch(() => ({}));
            if (data.success) {
                cloudAPIs[idx].hasKey = keyVal.length > 0;
                if (!keyVal) cloudAPIs[idx].enabled = false;
                cloudAPIs[idx].status = keyVal && cloudAPIs[idx].enabled ? 'connected' : (keyVal ? 'disconnected' : 'disconnected');
                if (window.showToast) window.showToast('API key saved and synced with backend', 'success');
            } else {
                if (window.showToast) window.showToast(data.error || 'Failed to save key', 'error');
            }
        } catch (e) {
            if (window.showToast) window.showToast('Request failed', 'error');
        }
        renderCloudAPIs();
    }

    // Offline path: Save to backend (realtime), Copy
    document.getElementById('offline-save-btn')?.addEventListener('click', saveOfflinePath);
    document.getElementById('offline-path-input')?.addEventListener('blur', function () {
        const path = this.value?.trim();
        if (path && path !== (window._offlineModelsPath || '')) saveOfflinePath();
    });
    document.getElementById('offline-path-input')?.addEventListener('keydown', function (e) {
        if (e.key === 'Enter') { e.preventDefault(); saveOfflinePath(); }
    });
    document.getElementById('offline-open-folder-btn')?.addEventListener('click', openModelsFolder);
    async function openModelsFolder() {
        const path = document.getElementById('offline-path-input')?.value?.trim() || window._offlineModelsPath || '';
        try {
            const r = await fetch('/api/v1/brain/open-models-folder', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ path: path || undefined })
            });
            const d = await r.json().catch(() => ({}));
            if (d.success) {
                if (window.showToast) window.showToast('Folder opened in Explorer/Finder', 'success');
            } else if (window.showToast) window.showToast(d.error || 'Could not open folder', 'error');
        } catch (e) {
            if (window.showToast) window.showToast('Could not open folder', 'error');
        }
    }
    document.getElementById('offline-copy-btn')?.addEventListener('click', () => {
        const path = document.getElementById('offline-path-input')?.value?.trim() || window._offlineModelsPath || '';
        if (path) {
            navigator.clipboard.writeText(path).then(() => {
                if (window.showToast) window.showToast('Path copied to clipboard', 'success');
            }).catch(() => { });
        }
    });
    async function saveOfflinePath() {
        const input = document.getElementById('offline-path-input');
        const path = input?.value?.trim() || '';
        if (!path) return;
        try {
            const r = await fetch('/api/v1/brain/models_root', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ models_root: path })
            });
            const d = await r.json();
            if (d.success) {
                window._offlineModelsPath = path;
                if (window.showToast) window.showToast('Offline path saved; backend updated.', 'success');
                await scanModels();
            } else if (window.showToast) window.showToast(d.error || 'Failed to save path', 'error');
        } catch (e) {
            if (window.showToast) window.showToast('Failed to save path', 'error');
        }
    }

    async function loadAutopilot() {
        try {
            const r = await fetch('/api/v1/brain/autopilot');
            if (r.ok) {
                const d = await r.json();
                const cb = document.getElementById('autopilot-toggle');
                if (cb) cb.checked = !!d.enabled;
            }
        } catch (_) { }
    }
    async function setAutopilot(enabled) {
        try {
            const r = await fetch('/api/v1/brain/autopilot', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: enabled })
            });
            const d = await r.json();
            if (d.success && window.showToast) window.showToast(enabled ? 'Autopilot on' : 'Autopilot off', 'success');
            else if (!d.success && window.showToast) window.showToast(d.error || 'Failed', 'error');
        } catch (e) {
            if (window.showToast) window.showToast('Failed to set autopilot', 'error');
        }
    }

    // Real-time token/call count: poll usage every 12s and refresh displayed stats
    let usageRefreshInterval = null;
    async function refreshUsageOnly() {
        try {
            const r = await fetch('/api/v1/brain/models/usage');
            if (!r.ok) return;
            const data = await r.json().catch(() => null);
            const stats = (data && data.stats) ? data.stats : {};
            usageStats = stats;
            localModelsData = localModelsData.map(m => ({
                ...m,
                calls: stats[m.name]?.calls ?? m.calls,
                tokens: stats[m.name]?.tokens ?? m.tokens
            }));
            renderLocalModels();
            renderUsageStats();
        } catch (_) { }
    }

    function startUsageRefresh() {
        if (usageRefreshInterval) clearInterval(usageRefreshInterval);
        usageRefreshInterval = setInterval(refreshUsageOnly, 12000);
    }

    // Init - load from APIs
    document.addEventListener('DOMContentLoaded', async () => {
        document.getElementById('add-cloud-api-btn')?.addEventListener('click', showAddCloudApiModal);
        await scanModels(); // Auto-scan on load
        loadAutopilot();
        startUsageRefresh(); // Sync token/call counts in real time
    });
</script>
{% endblock %}