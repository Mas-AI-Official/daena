{% extends "base.html" %}

{% block title %}Daena Office{% endblock %}

{% block head %}
<style>
    .sources-hidden {
        display: none !important;
    }

    .source-item a {
        max-width: 12rem;
    }

    /* Custom Scrollbar */
    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }

    .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
    }

    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    /* Animations */
    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(5px);
        }

        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .animate-fade-in {
        animation: fadeIn 0.3s ease-out forwards;
    }

    /* Sidebar Panel Transition */
    #sidebar-panel {
        transition: width 0.3s ease, min-width 0.3s ease, max-width 0.3s ease, opacity 0.3s ease;
    }

    /* Sticky Sidebar Resizer */
    #sidebar-resize-handle {
        position: absolute;
        top: 0;
        bottom: 0;
        cursor: col-resize;
        width: 8px !important;
        /* Wider hit area */
        right: -4px !important;
        /* Centered on border */
        z-index: 50;
        background: rgba(255, 255, 255, 0);
        /* Invisible by default */
        transition: background 0.2s;
    }

    #sidebar-resize-handle:hover,
    #sidebar-resize-handle:active {
        background: rgba(255, 215, 0, 0.4) !important;
        /* Gold highlight on hover */
    }

    /* Swimmer Effect for Thinking */
    @keyframes swimmer {
        0% {
            background-position: -200% 0;
        }

        100% {
            background-position: 200% 0;
        }
    }

    .swimmer {
        background: linear-gradient(90deg,
                rgba(255, 215, 0, 0.1) 25%,
                rgba(255, 215, 0, 0.4) 50%,
                rgba(255, 215, 0, 0.1) 75%);
        background-size: 200% 100%;
        animation: swimmer 2s infinite linear;
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        display: inline-block;
    }

    /* Minimal Thinking Style */
    .thinking-wrapper {
        margin-bottom: 0.5rem;
        transition: all 0.3s ease;
    }
</style>
{% endblock %}

{% block content %}
<div class="flex h-[calc(100vh-7rem)] gap-6">
    <!-- Chat Sessions Sidebar -->
    <div id="sidebar-panel" class="flex-shrink-0 glass-panel rounded-xl relative transition-all duration-300 ease-out"
        style="width: 15rem; max-width: 40rem; display: flex;">

        <!-- Inner Wrapper for content (clips overflow) -->
        <div class="flex flex-col h-full w-full overflow-hidden" id="sidebar-content-wrapper">
            <!-- Header -->
            <div class="p-4 border-b border-white/10 flex items-center justify-between bg-black/20 flex-shrink-0">
                <h3 class="font-medium text-white">Sessions</h3>
                <button onclick="createNewSession()" class="text-daena-gold hover:text-white transition-colors">
                    <i class="fas fa-plus"></i>
                </button>
            </div>

            <!-- Category Filter -->
            <div class="p-3 border-b border-white/10 bg-black/10 flex-shrink-0">
                <select id="category-filter"
                    class="w-full border border-white/10 rounded px-3 py-2 text-white text-sm focus:outline-none focus:border-daena-gold/50"
                    style="background-color: #1a1a2e;" onchange="filterByCategory()">
                    <option value="all">All Sessions</option>
                    <option value="executive">üëë Executive</option>
                    <option value="departments">üè¢ Departments</option>
                    <option value="engineering">‚öôÔ∏è Engineering</option>
                    <option value="product">üì¶ Product</option>
                    <option value="sales">üíº Sales</option>
                    <option value="marketing">üì¢ Marketing</option>
                    <option value="finance">üí∞ Finance</option>
                    <option value="hr">üë• HR</option>
                    <option value="legal">‚öñÔ∏è Legal</option>
                    <option value="customer">üéØ Customer</option>
                    <option value="agents">ü§ñ Agents</option>
                    <option value="general">üí¨ General</option>
                </select>
            </div>

            <!-- Batch Actions Toolbar -->
            <div id="batch-toolbar" class="hidden px-2 py-2 border-b border-white/10 bg-black/30 flex-shrink-0">
                <div class="flex items-center justify-between text-xs">
                    <label class="flex items-center gap-2 text-gray-400 cursor-pointer hover:text-white">
                        <input type="checkbox" id="select-all-checkbox" onchange="toggleSelectAll()"
                            class="accent-daena-gold">
                        <span id="selection-count">0 selected</span>
                    </label>
                    <div class="flex gap-1">
                        <button onclick="exportSelectedChats()"
                            class="px-2 py-1 text-gray-400 hover:text-white hover:bg-white/10 rounded"
                            title="Export Selected">
                            <i class="fas fa-download"></i>
                        </button>
                        <button onclick="deleteSelectedChats()"
                            class="px-2 py-1 text-gray-400 hover:text-red-400 hover:bg-red-500/10 rounded"
                            title="Delete Selected">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            </div>

            <!-- New Chat Button -->
            <div class="p-2 border-b border-white/10 flex-shrink-0">
                <button onclick="createNewSession()" id="new-chat-btn"
                    class="w-full flex items-center justify-center gap-2 px-3 py-2 bg-daena-gold hover:bg-yellow-500 text-black font-bold rounded-lg transition-colors">
                    <i class="fas fa-plus"></i> New Chat
                </button>
            </div>

            <!-- Sessions List -->
            <div class="flex-1 overflow-y-auto p-2 space-y-1" id="sessions-list">
                <div class="text-center py-4 text-gray-500 text-sm">Loading...</div>
            </div>

            <!-- Toggle Selection Mode Button -->
            <div class="p-2 border-t border-white/10 flex gap-2 flex-shrink-0">
                <button onclick="toggleSelectionMode()" id="selection-mode-btn"
                    class="flex-1 text-xs text-gray-400 hover:text-white hover:bg-white/5 rounded py-1 transition-colors">
                    <i class="fas fa-check-square mr-1"></i>
                </button>
                <button onclick="showDeletedSessions()" id="restore-deleted-btn"
                    class="flex-1 text-xs text-gray-400 hover:text-green-400 hover:bg-green-500/10 rounded py-1 transition-colors">
                    <i class="fas fa-trash-restore mr-1"></i>
                </button>
            </div>
        </div>

        <!-- Hover expand toggle button (absolute positioned, VISIBLE even if sidebar width is 0 due to overflow:visible on parent) -->
        <button id="sidebar-toggle-btn"
            class="absolute top-1/2 -right-3 transform -translate-y-1/2 w-6 h-12 bg-black/80 border border-white/20 rounded-r-lg flex items-center justify-center cursor-pointer text-gray-400 hover:text-daena-gold transition-colors z-[60]"
            onclick="toggleSidebarState()" title="Toggle Sidebar">
            <i class="fas fa-chevron-left text-xs" id="sidebar-toggle-icon"></i>
        </button>

        <!-- Resize Handle -->
        <div id="sidebar-resize-handle"></div>
    </div>

    <!-- Chat Area -->
    <div class="flex-1 flex flex-col glass-panel rounded-xl overflow-hidden relative">
        <!-- Chat Header -->
        <div class="h-14 border-b border-white/10 flex items-center justify-between px-6 bg-black/20">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-full bg-daena-gold flex items-center justify-center text-black font-bold">D
                </div>
                <div>
                    <h3 class="font-medium text-white">Daena VP</h3>
                    <p class="text-xs text-green-400 flex items-center gap-2" id="brain-status-indicator">
                        <span class="flex items-center gap-1">
                            <span class="w-1.5 h-1.5 rounded-full bg-gray-500" id="brain-dot"></span>
                            <span id="brain-text">Checking...</span>
                        </span>
                        <span id="routing-mode-badge"
                            class="hidden px-2 py-0.5 rounded-full bg-white/10 text-[10px] text-gray-300 border border-white/10">
                            LOCAL
                        </span>
                    </p>
                </div>
            </div>
            <div class="flex items-center gap-2">
                <!-- Category Badge -->
                <div id="current-category-badge" class="hidden px-3 py-1 rounded-full text-xs font-medium"></div>

                <!-- Actions -->
                <button onclick="exportChat('json')" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Export as JSON">
                    <i class="fas fa-download"></i>
                </button>
                <button onclick="exportChat('txt')" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Export as Text">
                    <i class="fas fa-file-alt"></i>
                </button>
                <button onclick="shareChat()" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Copy Share Link">
                    <i class="fas fa-share-alt"></i>
                </button>
                <button onclick="toggleToolConsole()" class="p-2 text-gray-400 hover:text-daena-gold transition-colors"
                    title="Tool Console" id="tool-console-btn">
                    <i class="fas fa-terminal"></i>
                </button>
                <button onclick="toggleVoice()" id="voice-toggle-btn"
                    class="p-2 text-gray-400 hover:text-white transition-colors" title="Toggle Voice">
                    <i class="fas fa-microphone-slash" id="voice-icon"></i>
                </button>
                <button onclick="openVoiceSettings()" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Voice Settings">
                    <i class="fas fa-sliders-h"></i>
                </button>
                <button onclick="showCategoryModal()" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Change Category">
                    <i class="fas fa-tag"></i>
                </button>
                <button onclick="clearContext()" class="p-2 text-gray-400 hover:text-white transition-colors"
                    title="Clear Context">
                    <i class="fas fa-eraser"></i>
                </button>
            </div>
        </div>

        <!-- Messages -->
        <div class="flex-1 overflow-y-auto p-6 space-y-6" id="chat-messages">
            <div class="flex gap-4">
                <div
                    class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">
                    D</div>
                <div class="flex-1">
                    <div
                        class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                        <p>Connecting to secure channel...</p>
                    </div>
                </div>
            </div>
            <!-- Scroll to latest: shown when user has scrolled up -->
            <button type="button" id="chat-scroll-to-bottom-btn" onclick="scrollChatToBottom(true)"
                title="Go to latest message"
                class="absolute bottom-4 right-6 z-10 flex items-center gap-2 px-3 py-2 rounded-full bg-daena-gold/90 hover:bg-daena-gold text-black text-sm font-medium shadow-lg transition-opacity"
                style="opacity: 0; pointer-events: none;">
                <i class="fas fa-chevron-down"></i>
                <span>Latest</span>
            </button>
        </div>

        <!-- Input Area -->
        <div class="flex-none p-4 border-t border-white/10 bg-black/20 z-10 sticky bottom-0">
            <div class="flex gap-2 mb-2 items-center">
                <button type="button" id="btn-search-mode" onclick="setSendMode('search')"
                    class="text-xs px-3 py-1.5 rounded-lg border border-white/20 text-gray-400 hover:border-daena-gold/50 hover:text-daena-gold transition-colors"
                    title="Quick search then answer (like Google + LLM)">
                    <i class="fas fa-search mr-1"></i> Search
                </button>
                <button type="button" id="btn-deep-search-mode" onclick="setSendMode('deep_search')"
                    class="text-xs px-3 py-1.5 rounded-lg border border-white/20 text-gray-400 hover:border-daena-gold/50 hover:text-daena-gold transition-colors"
                    title="Deep search: scrape pages and synthesize conclusion">
                    <i class="fas fa-globe mr-1"></i> Deep search
                </button>
                <button id="show-sources-btn" onclick="toggleShowSources()"
                    class="text-xs px-3 py-1.5 rounded-lg border border-white/20 text-gray-400 hover:border-daena-gold/50 hover:text-daena-gold transition-colors flex items-center gap-1"
                    title="Show sources: On/Off (citations below messages)">
                    <i class="fas fa-link text-xs"></i>
                    <span id="show-sources-label">Sources Off</span>
                </button>
                <span id="send-mode-badge" class="text-xs text-daena-gold hidden ml-auto"></span>
            </div>
            <form id="chat-form" class="flex gap-3 items-end">
                <textarea id="message-input" rows="1"
                    class="flex-1 bg-white/5 border border-white/10 rounded-xl px-4 py-3 text-white placeholder-gray-500 focus:outline-none focus:border-daena-gold/50 focus:bg-white/10 transition-all resize-none overflow-hidden"
                    placeholder="Ask Daena anything... (Shift+Enter for new line)" autocomplete="off"
                    style="min-height: 48px; max-height: 200px;"
                    oninput="this.style.height='auto';this.style.height=Math.min(this.scrollHeight,200)+'px'"></textarea>
                <button type="button" id="stop-stream-btn" onclick="stopStreaming()" title="Stop generating"
                    class="hidden bg-red-600 hover:bg-red-700 text-white font-bold px-5 rounded-xl transition-colors flex items-center gap-2">
                    <i class="fas fa-stop"></i>
                    <span>Stop</span>
                </button>
                <button type="submit" id="send-btn"
                    class="bg-daena-gold hover:bg-yellow-500 text-black font-bold px-6 rounded-xl transition-colors flex items-center gap-2">
                    <span>Send</span>
                    <i class="fas fa-paper-plane text-sm"></i>
                </button>
            </form>
        </div>
    </div>

    <!-- Tool Console Panel (Collapsible) -->
    <div id="tool-console" class="w-80 glass-panel rounded-xl overflow-hidden flex flex-col transition-all duration-300"
        style="display: none;">
        <div class="p-3 border-b border-white/10 bg-black/30 flex justify-between items-center">
            <h3 class="text-sm font-bold text-daena-gold flex items-center gap-2">
                <i class="fas fa-terminal"></i> Tool Console
            </h3>
            <button onclick="toggleToolConsole()" class="text-gray-400 hover:text-white">
                <i class="fas fa-times text-xs"></i>
            </button>
        </div>

        <!-- Quick Actions -->
        <div class="p-3 space-y-2 border-b border-white/10">
            <p class="text-xs text-gray-400 mb-2">Quick Actions</p>
            <div class="grid grid-cols-2 gap-1">
                <button onclick="executeQuickTool('health check')"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1">
                    <i class="fas fa-heartbeat text-green-400"></i> Health
                </button>
                <button onclick="executeQuickTool('show tables')"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1">
                    <i class="fas fa-database text-blue-400"></i> Tables
                </button>
                <button onclick="executeQuickTool('list routes')"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1">
                    <i class="fas fa-route text-purple-400"></i> Routes
                </button>
                <button onclick="executeQuickTool('analyze all')"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1">
                    <i class="fas fa-chart-pie text-yellow-400"></i> Analyze
                </button>
            </div>
            <!-- Desktop automation (Moltbot-like) -->
            <p class="text-xs text-gray-400 mb-2 mt-3">Desktop automation</p>
            <div class="grid grid-cols-2 gap-1">
                <button type="button" onclick="showDesktopClickForm()"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1"
                    title="Click at screen coordinates (requires AUTOMATION_ENABLE_DESKTOP=1)">
                    <i class="fas fa-mouse-pointer text-amber-400"></i> Click
                </button>
                <button type="button" onclick="showDesktopTypeForm()"
                    class="text-xs px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center gap-1"
                    title="Type text on desktop (requires AUTOMATION_ENABLE_DESKTOP=1)">
                    <i class="fas fa-keyboard text-amber-400"></i> Type
                </button>
            </div>
            <div id="desktop-click-form" class="hidden mt-2 space-y-2 p-2 bg-black/20 rounded border border-white/10">
                <div class="flex gap-2 items-center">
                    <input type="number" id="desktop-x" placeholder="X" min="0" step="1"
                        class="flex-1 text-xs bg-black/30 border border-white/10 rounded px-2 py-1.5 text-white w-16">
                    <input type="number" id="desktop-y" placeholder="Y" min="0" step="1"
                        class="flex-1 text-xs bg-black/30 border border-white/10 rounded px-2 py-1.5 text-white w-16">
                    <button type="button" onclick="runDesktopClick()"
                        class="text-xs px-2 py-1.5 bg-daena-gold hover:bg-yellow-500 text-black rounded font-bold">Run</button>
                </div>
            </div>
            <div id="desktop-type-form" class="hidden mt-2 space-y-2 p-2 bg-black/20 rounded border border-white/10">
                <div class="flex gap-2">
                    <input type="text" id="desktop-type-text" placeholder="Text to type on desktop"
                        class="flex-1 text-xs bg-black/30 border border-white/10 rounded px-2 py-1.5 text-white">
                    <button type="button" onclick="runDesktopType()"
                        class="text-xs px-2 py-1.5 bg-daena-gold hover:bg-yellow-500 text-black rounded font-bold">Run</button>
                </div>
            </div>
        </div>

        <!-- MCP Connections -->
        <div class="p-3 space-y-2 border-b border-white/10">
            <p class="text-xs text-gray-400 mb-2">MCP Connections</p>
            <div id="mcp-status" class="text-xs text-gray-500">Loading...</div>
            <button onclick="discoverMcpServers()"
                class="text-xs w-full px-2 py-1.5 bg-white/5 hover:bg-white/10 rounded text-gray-300 flex items-center justify-center gap-1">
                <i class="fas fa-search"></i> Discover Servers
            </button>
        </div>

        <!-- Tool Output -->
        <div class="flex-1 overflow-y-auto p-3">
            <p class="text-xs text-gray-400 mb-2">Output</p>
            <div id="tool-output"
                class="text-xs font-mono text-gray-300 bg-black/30 rounded p-2 min-h-[100px] whitespace-pre-wrap">
                Ready. Enter a command below or use quick actions.
            </div>
        </div>

        <!-- Command Input -->
        <div class="p-3 border-t border-white/10">
            <form onsubmit="executeToolCommand(event)" class="flex gap-2">
                <input type="text" id="tool-command"
                    class="flex-1 text-xs bg-black/30 border border-white/10 rounded px-2 py-1.5 text-white placeholder-gray-500 focus:outline-none focus:border-daena-gold/50"
                    placeholder="e.g. health check, click at 100 200, type on desktop hello">
                <button type="submit"
                    class="text-xs px-3 py-1.5 bg-daena-gold hover:bg-yellow-500 text-black rounded font-bold">
                    Run
                </button>
            </form>
        </div>
    </div>
</div>

<!-- Category Modal -->
<div id="category-modal"
    class="fixed inset-0 bg-black/80 backdrop-blur-sm hidden flex items-center justify-center z-50">
    <div class="glass-panel p-8 rounded-2xl max-w-md w-full mx-4">
        <div class="flex items-center justify-between mb-6">
            <h2 class="text-xl font-bold text-white">Change Session Category</h2>
            <button onclick="closeCategoryModal()" class="text-gray-400 hover:text-white">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="space-y-3">
            <button onclick="setCategory('executive')"
                class="w-full p-4 bg-white/5 hover:bg-white/10 rounded-lg text-left transition-colors">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üëë</span>
                    <div>
                        <p class="font-medium text-white">Executive</p>
                        <p class="text-xs text-gray-400">1-on-1 with Masoud (Founder)</p>
                    </div>
                </div>
            </button>
            <button onclick="setCategory('departments')"
                class="w-full p-4 bg-white/5 hover:bg-white/10 rounded-lg text-left transition-colors">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üè¢</span>
                    <div>
                        <p class="font-medium text-white">Departments</p>
                        <p class="text-xs text-gray-400">Department-level discussions</p>
                    </div>
                </div>
            </button>
            <button onclick="setCategory('agents')"
                class="w-full p-4 bg-white/5 hover:bg-white/10 rounded-lg text-left transition-colors">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">ü§ñ</span>
                    <div>
                        <p class="font-medium text-white">Agents</p>
                        <p class="text-xs text-gray-400">Agent coordination & tasks</p>
                    </div>
                </div>
            </button>
            <button onclick="setCategory('general')"
                class="w-full p-4 bg-white/5 hover:bg-white/10 rounded-lg text-left transition-colors">
                <div class="flex items-center gap-3">
                    <span class="text-2xl">üí¨</span>
                    <div>
                        <p class="font-medium text-white">General</p>
                        <p class="text-xs text-gray-400">Miscellaneous conversations</p>
                    </div>
                </div>
            </button>
        </div>
    </div>
</div>

<!-- Custom Modal for Delete/Rename -->
<div id="custom-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 backdrop-blur-sm">
    <div class="bg-gray-900 border border-white/10 rounded-2xl p-6 max-w-md w-full mx-4 shadow-2xl">
        <h3 id="modal-title" class="text-lg font-semibold text-white mb-4"></h3>
        <div id="modal-body" class="text-gray-300 mb-6"></div>
        <input type="text" id="modal-input"
            class="hidden w-full bg-white/5 border border-white/20 rounded-lg px-4 py-2 text-white mb-4 focus:outline-none focus:border-daena-gold/50" />
        <div class="flex gap-3 justify-end">
            <button onclick="closeModal()"
                class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg text-gray-300 transition-colors">
                Cancel
            </button>
            <button id="modal-confirm-btn"
                class="px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white transition-colors">
                Confirm
            </button>
        </div>
    </div>
</div>

{% endblock %}



{% block scripts %}
<script src="/static/js/websocket-client.js"></script>
<script src="/static/js/voice-client.js"></script>
<script>
    let currentSessionId = null;
    let allSessions = [];
    let currentCategory = 'all';
    let sendMode = null;  // 'search' | 'deep_search' ‚Äì R1-style search then answer
    let streamAbortController = null;  // only Stop button aborts; leaving chat/tab does not ‚Äî stream continues in background

    let chatPinnedToBottom = true;
    let scrollThrottle = null;

    // ChatGPT-style scroll: auto-scroll to last character only when user is at bottom; if user scrolls up, stop auto-scroll and show "Latest" button
    function computeChatPinned(container) {
        if (!container) return false;
        const threshold = 80;
        // Pinned if we are within [threshold] pixels of the bottom
        return container.scrollTop + container.clientHeight >= container.scrollHeight - threshold;
    }

    // Called on scroll event
    function onChatScroll() {
        const container = document.getElementById('chat-messages');
        if (!container) return;

        // Update pinned state based on user position
        // Only update if we are not currently forcing a scroll (optional optimization, but simple check is fine)
        chatPinnedToBottom = computeChatPinned(container);

        updateScrollToBottomButton();
    }

    function scrollChatToBottom(force = false) {
        const container = document.getElementById('chat-messages');
        if (!container) return;

        if (force || chatPinnedToBottom) {
            // Use requestAnimationFrame to smooth it out/throttle
            if (scrollThrottle) cancelAnimationFrame(scrollThrottle);
            scrollThrottle = requestAnimationFrame(() => {
                container.scrollTop = container.scrollHeight;
                // If we forced it, we are now pinned
                if (force) chatPinnedToBottom = true;
                updateScrollToBottomButton();
            });
        }
    }

    function updateScrollToBottomButton() {
        // Can be throttled too if scroll events are high frequency
        const container = document.getElementById('chat-messages');
        const btn = document.getElementById('chat-scroll-to-bottom-btn');
        if (!container || !btn) return;

        // Show button if NOT pinned (user is scrolled up)
        // We use the same pinned variable or recompute. 
        // Recomputing is safer for the UI state.
        const atBottom = computeChatPinned(container);

        if (atBottom) {
            btn.style.opacity = '0';
            btn.style.pointerEvents = 'none';
        } else {
            btn.style.opacity = '1';
            btn.style.pointerEvents = 'auto';
        }
    }

    // Unified stopStreaming implementation at the end of the script

    function setStreamingBeforeUnload(streaming) {
        if (streaming) {
            window._daenaStreamingBeforeUnload = function () { return true; };
            window.addEventListener('beforeunload', window._daenaStreamingBeforeUnload);
        } else {
            if (window._daenaStreamingBeforeUnload) {
                window.removeEventListener('beforeunload', window._daenaStreamingBeforeUnload);
                window._daenaStreamingBeforeUnload = null;
            }
        }
    }

    function setStreamingUI(streaming) {
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-stream-btn');
        const input = document.getElementById('message-input');

        // Always show send button, never hide it
        if (sendBtn) sendBtn.classList.remove('hidden');

        // Show stop button only when streaming (it will appear next to send)
        if (stopBtn) stopBtn.classList.toggle('hidden', !streaming);

        // Never disable input
        if (input) input.disabled = false;
        if (input && streaming) input.focus(); // Keep focus for typing
    }

    function setSendMode(mode) {
        sendMode = mode === sendMode ? null : mode;
        const btnSearch = document.getElementById('btn-search-mode');
        const btnDeep = document.getElementById('btn-deep-search-mode');
        const badge = document.getElementById('send-mode-badge');
        if (btnSearch) btnSearch.classList.toggle('border-daena-gold', sendMode === 'search');
        if (btnSearch) btnSearch.classList.toggle('text-daena-gold', sendMode === 'search');
        if (btnDeep) btnDeep.classList.toggle('border-daena-gold', sendMode === 'deep_search');
        if (btnDeep) btnDeep.classList.toggle('text-daena-gold', sendMode === 'deep_search');
        if (badge) {
            badge.classList.toggle('hidden', !sendMode);
            badge.textContent = sendMode === 'search' ? 'Search' : sendMode === 'deep_search' ? 'Deep search' : '';
        }
    }

    // --- Message Formatter ---
    function formatMessage(text) {
        if (!text) return '';
        // Convert [Title](url) to <a href="url" class="source-pill">[Title]</a>
        // And simple URLs to links if not in markdown
        let html = text
            .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;") // Basic cleanup first
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" class="source-pill" title="$2"><i class="fas fa-external-link-alt text-[9px] mr-1"></i>$1</a>')
            .replace(/`([^`]+)`/g, '<code class="bg-black/30 px-1 rounded text-orange-300">$1</code>')
            .replace(/\n/g, '<br>');
        return html;
    }

    // Category emoji map
    const categoryEmojis = {
        'executive': 'üëë',
        'departments': 'üè¢',
        'engineering': '‚öôÔ∏è',
        'product': 'üì¶',
        'sales': 'üíº',
        'marketing': 'üì¢',
        'finance': 'üí∞',
        'hr': 'üë•',
        'legal': '‚öñÔ∏è',
        'customer': 'üéØ',
        'agents': 'ü§ñ',
        'general': 'üí¨'
    };

    const categoryColors = {
        'executive': '#D4AF37',
        'departments': '#8B5CF6',
        'engineering': '#3B82F6',
        'product': '#10B981',
        'sales': '#F59E0B',
        'marketing': '#EF4444',
        'finance': '#00CED1',
        'hr': '#E91E7F',
        'legal': '#9370DB',
        'customer': '#32CD32',
        'agents': '#3B82F6',
        'general': '#6B7280'
    };

    function applyShowSources(on) {
        localStorage.setItem('daena_office_show_sources', on ? 'on' : 'off');
        const label = document.getElementById('show-sources-label');
        if (label) label.textContent = on ? 'Sources On' : 'Sources Off';
        document.querySelectorAll('[id$="-sources"]').forEach(el => {
            if (on) el.classList.remove('sources-hidden');
            else el.classList.add('sources-hidden');
        });
        const btn = document.getElementById('show-sources-btn');
        if (btn) btn.classList.toggle('text-daena-gold', on);
    }

    function toggleShowSources() {
        const on = localStorage.getItem('daena_office_show_sources') !== 'on';
        applyShowSources(on);
        window.showToast?.(on ? 'Sources visible below messages' : 'Sources hidden', 'info');
    }

    function toggleSidebarState() {
        const sidebar = document.getElementById('sidebar-panel');
        const icon = document.getElementById('sidebar-toggle-icon');
        if (!sidebar || !icon) return;

        // Check if currently collapsed
        const isCollapsed = sidebar.style.width === '0px';

        if (isCollapsed) {
            // Expand
            // sidebar.style.display = 'flex'; // No longer toggling display property
            requestAnimationFrame(() => {
                sidebar.style.width = '15rem';
                icon.classList.remove('fa-chevron-right');
                icon.classList.add('fa-chevron-left');
                localStorage.setItem('daena_office_sidebar_collapsed', 'false');
            });
        } else {
            // Collapse
            sidebar.style.width = '0px';
            // setTimeout(() => {
            //     sidebar.style.display = 'none'; 
            // }, 300); 
            icon.classList.remove('fa-chevron-left');
            icon.classList.add('fa-chevron-right');
            localStorage.setItem('daena_office_sidebar_collapsed', 'true');
        }
    }

    document.addEventListener('DOMContentLoaded', async () => {
        // Restore sidebar state
        const savedCollapsed = localStorage.getItem('daena_office_sidebar_collapsed') === 'true';
        if (savedCollapsed) {
            const sidebar = document.getElementById('sidebar-panel');
            const icon = document.getElementById('sidebar-toggle-icon');
            if (sidebar) {
                sidebar.style.width = '0px';
                // sidebar.style.display = 'none'; // Don't hide, just zero width
            }
            if (icon) {
                icon.classList.remove('fa-chevron-left');
                icon.classList.add('fa-chevron-right');
            }
        }

        applyShowSources(localStorage.getItem('daena_office_show_sources') === 'on');
        await checkBrainStatus();
        showInitialGreeting(); // Replace static "Connecting to secure channel..." message
        await loadSessions();

        // Only create new session if there are no existing sessions
        if (!currentSessionId && allSessions.length === 0) {
            await createNewSession();
        } else if (allSessions.length > 0 && !currentSessionId) {
            // Load the first session if none selected
            await loadSession(allSessions[0].session_id);
        }

        // Add Enter key support for message input (Enter sends, Shift+Enter for new line with textarea)
        const msgInput = document.getElementById('message-input');
        if (msgInput) msgInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const chatForm = document.getElementById('chat-form');
                if (chatForm) chatForm.dispatchEvent(new Event('submit'));
            }
        });

        // Scroll-to-latest button: show when user has scrolled up
        const chatMessagesEl = document.getElementById('chat-messages');
        if (chatMessagesEl) {
            chatMessagesEl.addEventListener('scroll', onChatScroll);
            updateScrollToBottomButton();
        }

        // Add Delete key for session deletion
        document.addEventListener('keydown', (e) => {
            // Only handle Delete key when not typing in an input
            if (e.key === 'Delete' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) {
                e.preventDefault();
                if (selectionMode && selectedSessions.size > 0) {
                    // Delete all selected sessions
                    deleteSelectedChats();
                } else if (currentSessionId) {
                    // Delete current session
                    deleteSession(currentSessionId);
                }
            }
        });

        // Listen for WebSocket brain status updates
        if (window.wsClient) {
            window.wsClient.on('brain.status.changed', (data) => {
                updateBrainStatusUI(data);
            });

            // Listen for chat message events for real-time updates
            window.wsClient.on('chatMessage', (data) => {
                // If this message is for the current session, add it to the UI
                if (data.session_id === currentSessionId) {
                    const container = document.getElementById('chat-messages');
                    if (container && data.sender === 'assistant') {
                        container.insertAdjacentHTML('beforeend', `
                            <div class="flex gap-4">
                                <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                                <div class="flex-1">
                                    <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                                        <p class="whitespace-pre-wrap leading-relaxed">${data.content || ''}</p>
                                    </div>
                                </div>
                            </div>
                        `);
                        scrollChatToBottom();
                    }
                }
                loadSessions();
            });
        }

        // Recheck brain status every 30 seconds
        setInterval(checkBrainStatus, 30000);
    });

    async function checkBrainStatus() {
        try {
            const status = await window.api.getBrainStatus();
            updateBrainStatusUI(status);
        } catch (e) {
            updateBrainStatusUI({ connected: false, error: e.message });
        }
    }

    function updateBrainStatusUI(status) {
        const dot = document.getElementById('brain-dot');
        const text = document.getElementById('brain-text');
        const sendBtn = document.getElementById('send-btn');
        const input = document.getElementById('message-input');

        if (status.connected) {
            dot.className = 'w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse';
            text.textContent = 'Brain Active';
            text.className = 'text-xs text-green-400 flex items-center gap-1';

            // Only enable controls if not currently streaming
            if (!streamAbortController) {
                sendBtn.disabled = false;
                input.disabled = false;
                input.placeholder = 'Ask Daena anything...';
            }
        } else {
            dot.className = 'w-1.5 h-1.5 rounded-full bg-red-500';
            text.textContent = 'Brain Offline';
            text.className = 'text-xs text-red-400 flex items-center gap-1';

            // Always disable if offline, even if streaming (stream will likely fail anyway)
            sendBtn.disabled = true;
            input.disabled = true;
            input.placeholder = 'Brain is offline - please start Ollama';
        }
    }

    function showInitialGreeting() {
        const container = document.getElementById('chat-messages');
        const brain = document.getElementById('brain-text');
        const isOnline = brain && brain.textContent === 'Brain Active';

        let greeting = '';
        if (isOnline) {
            greeting = `Hey boss! üëã I'm Daena, your AI Vice President. Brain is connected and ready. How can I help you today?`;
        } else {
            greeting = `Hey boss! üëã I'm Daena, your AI Vice President. The brain appears to be offline right now. Please ensure Ollama is running (run <code>start_daena.bat</code>). Once connected, I'll be ready to assist!`;
        }

        container.innerHTML = `
            <div class="flex gap-4">
                <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                <div class="flex-1">
                    <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                        <p class="whitespace-pre-wrap leading-relaxed">${greeting}</p>
                    </div>
                </div>
            </div>
        `;
    }

    async function loadSessions() {
        try {
            let category = currentCategory === 'all' ? null : currentCategory;

            // Use unified chat API (Phase 3) for category-based queries
            if (category && window.sessionManager) {
                try {
                    // Call unified chat sessions-by-category endpoint
                    const sessions = await window.sessionManager.getSessionsByCategory(category);
                    allSessions = sessions || [];
                    console.log(`‚úÖ Loaded ${allSessions.length} sessions for category '${category}'`);
                } catch (e) {
                    console.error('Unified API failed, falling back:', e);
                    // Fallback to old API
                    const data = await window.api.getDaenaChatSessions(category);
                    allSessions = data.sessions || [];
                }
            } else if (currentCategory === 'all') {
                // Load all sessions
                const data = await window.api.getDaenaChatSessions(null);
                allSessions = data.sessions || [];
            } else {
                // Fallback for edge cases
                const data = await window.api.getDaenaChatSessions(category);
                allSessions = data.sessions || [];
            }

            renderSessions();
        } catch (e) {
            console.error('Failed to load sessions:', e);
            allSessions = [];
            renderSessions();
        }
    }

    function formatDate(dateStr) {
        if (!dateStr) return 'Recently';
        try {
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) return 'Recently';
            const now = new Date();
            const diff = now - date;
            if (diff < 60000) return 'Just now';
            if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
            if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
            if (diff < 604800000) return Math.floor(diff / 86400000) + 'd ago';
            return date.toLocaleDateString();
        } catch {
            return 'Recently';
        }
    }

    // Selection mode state
    let selectionMode = false;
    let selectedSessions = new Set();

    function renderSessions() {
        const list = document.getElementById('sessions-list');
        let filtered = allSessions;

        if (filtered.length === 0) {
            list.innerHTML = '<div class="text-center py-4 text-gray-500 text-xs">No sessions</div>';
            return;
        }

        list.innerHTML = filtered.map(session => {
            const emoji = categoryEmojis[session.category] || 'üí¨';
            const isActive = session.session_id === currentSessionId;
            const isSelected = selectedSessions.has(session.session_id);
            const dateStr = formatDate(session.last_activity || session.updated_at || session.created_at);

            return `
                <div class="group relative ${isSelected ? 'bg-daena-gold/10 rounded-lg' : ''}">
                    ${selectionMode ? `
                        <div class="absolute left-2 top-1/2 -translate-y-1/2 z-10">
                            <input type="checkbox" 
                                class="session-checkbox accent-daena-gold cursor-pointer"
                                data-session-id="${session.session_id}"
                                ${isSelected ? 'checked' : ''}
                                onchange="toggleSessionSelection('${session.session_id}', this.checked)"
                            >
                        </div>
                    ` : ''}
                    <button onclick="${selectionMode ? `toggleSessionSelection('${session.session_id}')` : `loadSession('${session.session_id}')`}" 
                        class="w-full text-left ${selectionMode ? 'pl-8' : 'px-3'} py-2 rounded-lg hover:bg-white/5 transition-colors ${isActive && !selectionMode ? 'bg-white/10' : ''}">
                        <div class="flex items-start gap-2">
                            <span class="text-lg mt-0.5">${emoji}</span>
                            <div class="flex-1 min-w-0">
                                <p class="text-sm text-gray-200 truncate font-medium">${session.title || 'New Chat'}</p>
                                <p class="text-xs text-gray-500 truncate">${dateStr}</p>
                            </div>
                        </div>
                    </button>
                    ${!selectionMode ? `
                        <div class="absolute right-1 top-1 hidden group-hover:flex gap-1">
                            <button onclick="event.stopPropagation(); renameSession('${session.session_id}', '${(session.title || 'New Chat').replace(/'/g, "\\'")}')"
                                class="p-1.5 text-gray-400 hover:text-white hover:bg-white/10 rounded" title="Rename">
                                <i class="fas fa-edit text-xs"></i>
                            </button>
                            <button onclick="event.stopPropagation(); exportSession('${session.session_id}')"
                                class="p-1.5 text-gray-400 hover:text-blue-400 hover:bg-blue-500/10 rounded" title="Export">
                                <i class="fas fa-download text-xs"></i>
                            </button>
                            <button onclick="event.stopPropagation(); deleteSession('${session.session_id}')"
                                class="p-1.5 text-gray-400 hover:text-red-400 hover:bg-red-500/10 rounded" title="Delete">
                                <i class="fas fa-trash text-xs"></i>
                            </button>
                        </div>
                    ` : ''}
                </div>
            `;
        }).join('');

        updateSelectionCount();
    }

    function toggleSelectionMode() {
        selectionMode = !selectionMode;
        selectedSessions.clear();

        const toolbar = document.getElementById('batch-toolbar');
        const btn = document.getElementById('selection-mode-btn');

        if (selectionMode) {
            toolbar.classList.remove('hidden');
            btn.innerHTML = '<i class="fas fa-times mr-1"></i> Cancel Selection';
            btn.classList.add('text-daena-gold');
        } else {
            toolbar.classList.add('hidden');
            btn.innerHTML = '<i class="fas fa-check-square mr-1"></i> Select Multiple';
            btn.classList.remove('text-daena-gold');
        }

        renderSessions();
    }

    function toggleSessionSelection(sessionId, checked) {
        if (checked === undefined) {
            // Toggle if not specified
            if (selectedSessions.has(sessionId)) {
                selectedSessions.delete(sessionId);
            } else {
                selectedSessions.add(sessionId);
            }
        } else if (checked) {
            selectedSessions.add(sessionId);
        } else {
            selectedSessions.delete(sessionId);
        }
        updateSelectionCount();
        renderSessions();
    }

    function toggleSelectAll() {
        const checkbox = document.getElementById('select-all-checkbox');
        if (checkbox.checked) {
            allSessions.forEach(s => selectedSessions.add(s.session_id));
        } else {
            selectedSessions.clear();
        }
        updateSelectionCount();
        renderSessions();
    }

    function updateSelectionCount() {
        const countEl = document.getElementById('selection-count');
        countEl.textContent = `${selectedSessions.size} selected`;

        const selectAll = document.getElementById('select-all-checkbox');
        selectAll.checked = selectedSessions.size === allSessions.length && allSessions.length > 0;
        selectAll.indeterminate = selectedSessions.size > 0 && selectedSessions.size < allSessions.length;
    }

    async function deleteSelectedChats() {
        if (selectedSessions.size === 0) {
            window.showToast?.('No chats selected', 'warning');
            return;
        }

        showModal(
            'üóëÔ∏è Delete Selected Chats',
            `Are you sure you want to delete ${selectedSessions.size} chat(s)? This cannot be undone.`,
            'Delete All',
            false,
            '',
            async () => {
                try {
                    let deleted = 0;
                    for (const sessionId of selectedSessions) {
                        await window.api.deleteChatSession(sessionId);
                        deleted++;
                    }
                    selectedSessions.clear();
                    await loadSessions();
                    window.showToast?.(`Deleted ${deleted} chats`, 'success');
                } catch (e) {
                    window.showToast?.('Failed to delete some chats', 'error');
                }
            }
        );
    }

    async function exportSelectedChats() {
        if (selectedSessions.size === 0) {
            window.showToast?.('No chats selected', 'warning');
            return;
        }

        try {
            const exportData = {
                exported_at: new Date().toISOString(),
                chats: []
            };

            for (const sessionId of selectedSessions) {
                const data = await window.api.getChatHistory(sessionId);
                exportData.chats.push({
                    session_id: sessionId,
                    title: data.session?.title || 'Untitled',
                    category: data.session?.category || 'general',
                    messages: data.messages || []
                });
            }

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `daena-chats-export-${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            window.showToast?.(`Exported ${selectedSessions.size} chats`, 'success');
        } catch (e) {
            console.error('Export error:', e);
            window.showToast?.('Failed to export chats', 'error');
        }
    }

    function filterByCategory() {
        currentCategory = document.getElementById('category-filter').value;
        // Reload sessions with new category filter
        loadSessions();
    }

    async function createNewSession() {
        try {
            const data = await window.api.startChat();
            if (data.success) {
                currentSessionId = data.session?.session_id || data.session_id;
                await loadSessions();
                renderMessages(data.session?.messages || []);
                updateCategoryBadge(data.session?.category || 'executive');
            }
        } catch (e) {
            console.error('Create session error:', e);
            window.showToast?.('Failed to start new chat', 'error');
        }
    }

    // Modal functions
    let modalCallback = null;

    // Start a new chat session
    async function startNewChat() {
        try {
            // Create new session via API
            const response = await window.api.request('/chat-history/sessions', {
                method: 'POST',
                body: JSON.stringify({
                    title: 'New Chat',
                    category: currentCategory || 'executive',
                    scope_type: 'executive',
                    scope_id: 'daena'
                })
            });

            if (response && response.session_id) {
                currentSessionId = response.session_id;

                // Clear messages and show welcome
                document.getElementById('chat-messages').innerHTML = `
                    <div class="flex gap-4">
                        <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                        <div class="flex-1">
                            <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                                <p>Hello! I'm Daena, your AI VP. How can I help you today?</p>
                            </div>
                        </div>
                    </div>
                `;

                // Reload sessions list to show the new session
                await loadSessions();

                // Focus input
                document.getElementById('message-input')?.focus();

                window.showToast?.('New chat started', 'success');
            }
        } catch (error) {
            console.error('Failed to create new chat:', error);
            window.showToast?.('Failed to start new chat', 'error');

            // Fallback: just clear the messages
            currentSessionId = null;
            document.getElementById('chat-messages').innerHTML = `
                <div class="flex gap-4">
                    <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                    <div class="flex-1">
                        <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                            <p>Hello! I'm Daena, your AI VP. How can I help you today?</p>
                        </div>
                    </div>
                </div>
            `;
        }
    }

    function showModal(title, body, confirmText, isInput = false, inputValue = '', onConfirm = null) {
        const modal = document.getElementById('custom-modal');
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-body').innerHTML = body;
        const confirmBtn = document.getElementById('modal-confirm-btn');
        confirmBtn.textContent = confirmText;
        confirmBtn.className = confirmText.toLowerCase().includes('delete')
            ? 'px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white transition-colors'
            : 'px-4 py-2 bg-daena-gold hover:bg-yellow-500 rounded-lg text-black transition-colors';

        const input = document.getElementById('modal-input');
        if (isInput) {
            input.classList.remove('hidden');
            input.value = inputValue;
            setTimeout(() => input.focus(), 100);
        } else {
            input.classList.add('hidden');
        }

        modalCallback = onConfirm;
        confirmBtn.onclick = () => {
            const inputVal = input.value;
            const callback = modalCallback;  // Save callback before closeModal nullifies it
            closeModal();
            if (callback) callback(inputVal);  // Use saved callback
        };

        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    function closeModal() {
        const modal = document.getElementById('custom-modal');
        modal.classList.add('hidden');
        modal.classList.remove('flex');
        modalCallback = null;
    }

    async function deleteSession(sessionId) {
        showModal(
            'üóëÔ∏è Delete Chat',
            'Are you sure you want to delete this chat session? This action cannot be undone.',
            'Delete',
            false,
            '',
            async () => {
                try {
                    await window.api.deleteChatSession(sessionId);
                    if (currentSessionId === sessionId) {
                        currentSessionId = null;
                    }
                    await loadSessions();
                    if (allSessions.length > 0 && !currentSessionId) {
                        await loadSession(allSessions[0].session_id);
                    } else if (allSessions.length === 0) {
                        document.getElementById('chat-messages').innerHTML = '<div class="text-center py-8 text-gray-500">Start a new chat</div>';
                    }
                    window.showToast?.('Chat deleted', 'info');
                } catch (e) {
                    window.showToast?.('Failed to delete chat', 'error');
                }
            }
        );
    }

    async function renameSession(sessionId, currentTitle) {
        showModal(
            '‚úèÔ∏è Rename Chat',
            'Enter a new title for this chat session:',
            'Save',
            true,
            currentTitle || 'Untitled',
            async (newTitle) => {
                if (!newTitle || newTitle === currentTitle) return;
                try {
                    await window.api.request(`/chat-history/sessions/${sessionId}`, {
                        method: 'PUT',
                        body: JSON.stringify({ title: newTitle })
                    });
                    await loadSessions();
                    window.showToast?.('Chat renamed', 'success');
                } catch (e) {
                    window.showToast?.('Failed to rename chat', 'error');
                }
            }
        );
    }

    async function exportSession(sessionId) {
        try {
            window.showToast?.('Exporting chat...', 'info');
            // Open the export URL directly to trigger download
            window.open(`/api/v1/daena/chat/${sessionId}/export`, '_blank');
        } catch (e) {
            window.showToast?.('Failed to export chat', 'error');
        }
    }

    async function showDeletedSessions() {
        try {
            const data = await window.api.request('/daena/chat/deleted');
            if (!data.deleted_sessions || data.deleted_sessions.length === 0) {
                window.showToast?.('No deleted chats to restore', 'info');
                return;
            }

            // Create modal content
            const listHtml = data.deleted_sessions.map(s => `
                <div class="flex items-center justify-between p-3 bg-white/5 rounded-lg mb-2">
                    <div>
                        <p class="text-white font-medium">${s.title || 'Untitled'}</p>
                        <p class="text-gray-400 text-xs">Deleted: ${new Date(s.deleted_at).toLocaleDateString()}</p>
                    </div>
                    <button onclick="restoreSession('${s.session_id}')" 
                        class="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-sm">
                        Restore
                    </button>
                </div>
            `).join('');

            window.showModal(
                'Restore Deleted Chats',
                `<div class="max-h-64 overflow-y-auto">${listHtml}</div>`,
                'Close',
                false
            );
        } catch (e) {
            window.showToast?.('Failed to load deleted chats', 'error');
        }
    }

    async function restoreSession(sessionId) {
        try {
            await window.api.request(`/daena/chat/${sessionId}/restore`, { method: 'POST' });
            window.showToast?.('Chat restored!', 'success');
            await loadSessions();
            // Close modal if open
            document.querySelector('.modal-overlay')?.remove();
        } catch (e) {
            window.showToast?.('Failed to restore chat', 'error');
        }
    }

    // Global registry for streaming sessions to persist state when switching views
    window._streamContexts = window._streamContexts || new Map();

    async function loadSession(sessionId) {
        currentSessionId = sessionId;

        // Check if we already have an active stream context in memory or localStorage
        const activeContext = window._streamContexts.get(sessionId);
        const isStreaming = !!activeContext || !!localStorage.getItem(`daena_streaming_${sessionId}`);
        setStreamingUI(isStreaming);

        try {
            const data = await window.api.getChatHistory(sessionId);
            if (data.success) {
                const messages = data.messages || data.session?.messages || [];
                renderMessages(messages);
                updateCategoryBadge(data.session?.category || 'general');
                renderSessions();

                // If this session is supposed to be streaming but we don't have a local context, try to re-attach
                if (!activeContext && (localStorage.getItem(`daena_streaming_${sessionId}`) || localStorage.getItem('daena_streaming_new'))) {
                    const rId = localStorage.getItem(`daena_streaming_id_${sessionId}`) || localStorage.getItem('daena_streaming_id_new');
                    resumeStreaming(sessionId, rId);
                } else if (activeContext) {
                    // Re-sync UI with the running context
                    syncStreamToUI(sessionId);
                }
            } else {
                window.showToast?.('Failed to load chat', 'error');
            }
        } catch (e) {
            console.error('Load session error:', e);
            window.showToast?.('Failed to load chat history', 'error');
        }
    }

    async function resumeStreaming(sessionId, responseId) {
        if (!sessionId || !responseId) return;

        // Safety: Don't resume twice or if already active
        if (window._streamContexts.has(sessionId)) {
            const existing = window._streamContexts.get(sessionId);
            if (!existing.pending && !existing.isResumed) return;
        }

        console.log(`[Streaming] Resuming session ${sessionId}...`);
        window._streamContexts.set(sessionId, { pending: true, responseId });

        const controller = new AbortController();
        if (sessionId === (currentSessionId || 'new')) streamAbortController = controller;

        // Use existing container if possible, otherwise placeholder
        const existingResponse = document.getElementById(responseId);
        if (!existingResponse) {
            let container = document.getElementById('chat-messages');
            const placeholder = `
                <div id="${responseId}" class="flex gap-4 assistant-placeholder">
                    <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                    <div class="flex-1">
                        <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                            <div id="${responseId}-text" class="whitespace-pre-wrap leading-relaxed"><i class="fas fa-circle-notch fa-spin"></i></div>
                            <div id="${responseId}-sources" class="mt-2 pt-2 border-t border-white/10 hidden"></div>
                        </div>
                    </div>
                </div>`;
            if (container) {
                container.insertAdjacentHTML('beforeend', placeholder);
                scrollChatToBottom(true);
            }
        }

        try {
            const response = await fetch('/api/v1/daena/chat/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message: '', session_id: sessionId }),
                signal: controller.signal
            });

            if (response.ok) {
                handleChatStream(sessionId, responseId, response);
            } else {
                // If stream not found, cleanup
                console.warn(`[Streaming] Stream for ${sessionId} not found on backend.`);
                doneStreaming(sessionId);
                const textEl = document.getElementById(`${responseId}-text`);
                if (textEl && textEl.querySelector('.fa-spin')) {
                    textEl.innerHTML = '<span class="text-gray-500 italic">[Stream ended]</span>';
                }
            }
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error("Failed to resume stream:", e);
                doneStreaming(sessionId);
            }
        }
    }

    function syncStreamToUI(sessionId) {
        const ctx = window._streamContexts.get(sessionId);
        if (!ctx) return;

        const responseId = ctx.responseId;
        const textEl = document.getElementById(`${responseId}-text`);
        if (!textEl) return; // Not on the right page/session view

        // Ensure thoughts UI is present if they were thinking
        if (ctx.thoughtTokens || ctx.isThinkingTokens) {
            ensureThoughtsUI(responseId);
            const thoughtsEl = document.getElementById(`${responseId}-thoughts`);
            if (thoughtsEl) {
                const contentDiv = thoughtsEl.querySelector('.thought-content');
                if (contentDiv) contentDiv.textContent = ctx.thoughtTokens;
                if (!ctx.isThinkingTokens) {
                    const statusEl = thoughtsEl.querySelector('.thoughts-status');
                    if (statusEl) statusEl.textContent = `Thought complete`;
                }
            }
        }

        const finalEl = document.getElementById(`${responseId}-final-answer`) || textEl;
        if (finalEl && ctx.fullText) {
            finalEl.innerHTML = formatMessage(ctx.fullText);
            scrollChatToBottom();
        }
    }

    function ensureThoughtsUI(responseId, shouldOpen = true) {
        let thoughtsEl = document.getElementById(`${responseId}-thoughts`);
        if (thoughtsEl) return thoughtsEl;

        const textEl = document.getElementById(`${responseId}-text`);
        if (!textEl) return null;

        const thoughtsContainer = document.createElement('div');
        thoughtsContainer.className = "thinking-wrapper";
        thoughtsContainer.innerHTML = `
            <div id="${responseId}-thoughts" class="transition-all duration-300">
                <div class="text-[10px] text-gray-500/60 select-none py-1 flex items-center gap-2">
                   <i class="fas fa-brain thoughts-icon text-daena-gold/30"></i>
                   <span class="font-medium uppercase tracking-wider swimmer thoughts-status">Thinking</span>
                   <span class="text-gray-500/40 text-[10px] font-mono ml-auto" id="${responseId}-timer">0.0s</span>
                </div>
                <!-- Hidden content container for logic compatibility -->
                <div class="thought-content hidden"></div>
            </div>
            <div id="${responseId}-final-answer" class="whitespace-pre-wrap leading-relaxed animate-fade-in mt-1"></div>
        `;

        if (textEl.querySelector('.fa-circle-notch')) {
            textEl.innerHTML = '';
        }
        textEl.appendChild(thoughtsContainer);
        return document.getElementById(`${responseId}-thoughts`);
    }

    async function handleChatStream(sessionId, responseId, response) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();

        // Initialize or get the stream context
        let ctx = window._streamContexts.get(sessionId);
        if (!ctx || ctx.pending) {
            ctx = {
                sessionId, responseId,
                fullText: '', thoughtTokens: '',
                isThinkingTokens: false, firstToken: true,
                buffer: '', sources: [],
                isResumed: true
            };
            window._streamContexts.set(sessionId, ctx);
        }

        // Ensure UI state is updated immediately
        if (currentSessionId === sessionId) {
            setStreamingUI(true);
            setStreamingBeforeUnload(true);

            // Clear spinner if we already have some text or if we are resuming
            const textEl = document.getElementById(`${responseId}-text`);
            if (textEl && (ctx.fullText || ctx.isResumed)) textEl.innerHTML = '';
        }

        localStorage.setItem(`daena_streaming_${sessionId}`, 'true');
        localStorage.setItem(`daena_streaming_id_${sessionId}`, responseId);

        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                ctx.buffer += decoder.decode(value, { stream: true });
                const lines = ctx.buffer.split('\n');
                ctx.buffer = lines.pop();

                for (const line of lines) {
                    if (line.trim() === '' || !line.startsWith('data: ')) continue;
                    try {
                        const data = JSON.parse(line.substring(6));

                        // Update UI ONLY if we are still looking at this session
                        const isCurrent = (currentSessionId === sessionId);

                        if (data.type === 'session' && data.session_id) {
                            // Backend sent real session ID for a new chat
                            if (!currentSessionId || sessionId === 'new' || sessionId === 'default') {
                                const oldId = sessionId;
                                currentSessionId = data.session_id;
                                sessionId = data.session_id; // update local Loop var

                                // Update registries
                                window._streamContexts.set(currentSessionId, ctx);
                                if (oldId !== currentSessionId) window._streamContexts.delete(oldId);

                                localStorage.setItem(`daena_streaming_${currentSessionId}`, 'true');
                                localStorage.setItem(`daena_streaming_id_${currentSessionId}`, responseId);
                                localStorage.removeItem(`daena_streaming_${oldId}`);
                                localStorage.removeItem(`daena_streaming_id_${oldId}`);

                                loadSessions();
                            }
                        } else if (data.type === 'token') {
                            let content = data.content;
                            if (content.includes('<think>')) { ctx.isThinkingTokens = true; content = content.replace('<think>', ''); }

                            if (ctx.isThinkingTokens) {
                                ctx.thoughtTokens += content;
                                if (ctx.thoughtTokens.includes('</think>')) {
                                    const parts = ctx.thoughtTokens.split('</think>');
                                    ctx.thoughtTokens = parts[0]; content = parts[1] || ''; ctx.isThinkingTokens = false;
                                } else content = '';
                            }

                            if (ctx.firstToken) {
                                if (isCurrent) {
                                    const textEl = document.getElementById(`${responseId}-text`);
                                    if (textEl) textEl.innerHTML = '';
                                }
                                ctx.firstToken = false;
                                ctx.isResumed = false;
                            }

                            if (isCurrent) {
                                let thoughtsEl = document.getElementById(`${responseId}-thoughts`);
                                if (ctx.thoughtTokens || ctx.isThinkingTokens) {
                                    // Don't auto-open if it's a resume (replay) to avoid jarring UI
                                    const openMode = !ctx.isResumed;
                                    thoughtsEl = ensureThoughtsUI(responseId, openMode);
                                    if (thoughtsEl) {
                                        const cDiv = thoughtsEl.querySelector('.thought-content');
                                        if (cDiv) { cDiv.textContent = ctx.thoughtTokens; cDiv.scrollTop = cDiv.scrollHeight; }
                                    }
                                }
                                if (!ctx.isThinkingTokens && thoughtsEl && thoughtsEl.dataset.interval !== 'done') {
                                    if (thoughtsEl.dataset.interval) clearInterval(thoughtsEl.dataset.interval);
                                    thoughtsEl.dataset.interval = 'done';
                                    const statusEl = thoughtsEl.querySelector('.thoughts-status');
                                    if (statusEl) { statusEl.textContent = `Thought complete`; statusEl.classList.remove('swimmer'); }
                                }

                                const finalEl = document.getElementById(`${responseId}-final-answer`) || document.getElementById(`${responseId}-text`);
                                if (finalEl && content) {
                                    ctx.fullText += content;
                                    finalEl.innerHTML = formatMessage(ctx.fullText);
                                    scrollChatToBottom();
                                }
                            } else {
                                // Background update
                                if (!ctx.isThinkingTokens) ctx.fullText += content;
                            }
                        } else if (data.type === 'status' && isCurrent) {
                            const thoughtsEl = ensureThoughtsUI(responseId);
                            if (thoughtsEl) {
                                const cDiv = thoughtsEl.querySelector('.thought-content');
                                if (cDiv) {
                                    const line = document.createElement('div');
                                    line.className = "text-daena-gold/40";
                                    line.innerHTML = `<span class="opacity-30">&gt;</span> ${data.content}`;
                                    cDiv.appendChild(line);
                                }
                            }
                        } else if (data.type === 'sources') {
                            ctx.sources = data.sources;
                            if (isCurrent) {
                                // (Simplified sources render)
                                const sEl = document.getElementById(`${responseId}-sources`);
                                if (sEl) { sEl.innerHTML = `<div class="text-[10px] text-gray-500">Sources (${data.sources.length})</div>`; sEl.classList.remove('hidden'); }
                            }
                        } else if (data.type === 'done') {
                            doneStreaming(sessionId);
                        }
                    } catch (e) { console.debug("Line parse err", e); }
                }
            }
        } finally {
            if (ctx.firstToken) doneStreaming(sessionId); // Nothing received
            // Final sync
            if (currentSessionId === sessionId) syncStreamToUI(sessionId);
        }
    }

    function doneStreaming(sessionId) {
        window._streamContexts.delete(sessionId);
        localStorage.removeItem(`daena_streaming_${sessionId}`);
        localStorage.removeItem(`daena_streaming_id_${sessionId}`);

        // Also cleanup the streamAbortController if it was this one
        if (window._activeStreams) window._activeStreams.delete(sessionId);

        if (currentSessionId === sessionId) {
            setStreamingUI(false);
            setStreamingBeforeUnload(false);
            if (typeof loadSessions === 'function') loadSessions();
        }
    }

    // Global stop function
    window.stopStreaming = function () {
        console.log("[Streaming] Manual stop requested...");
        if (streamAbortController) {
            streamAbortController.abort();
            streamAbortController = null;
        }

        // Signal backend to stop specifically for this session
        if (currentSessionId) {
            fetch('/api/v1/daena/chat/stop', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: currentSessionId })
            }).catch(e => { });

            // Cleanup UI and storage
            doneStreaming(currentSessionId);
            window.showToast?.('Streaming stopped', 'info');
        }

        setStreamingUI(false);
    };

    function updateCategoryBadge(category) {
        const badge = document.getElementById('current-category-badge');
        const emoji = categoryEmojis[category] || 'üí¨';
        const color = categoryColors[category] || '#6B7280';

        badge.textContent = `${emoji} ${category.charAt(0).toUpperCase() + category.slice(1)}`;
        badge.style.backgroundColor = `${color}20`;
        badge.style.color = color;
        badge.classList.remove('hidden');
    }

    function renderMessages(messages) {
        const container = document.getElementById('chat-messages');
        if (!messages || messages.length === 0) {
            container.innerHTML = '<div class="text-center py-8 text-gray-500">No messages yet. Start a conversation!</div>';
            return;
        }
        container.innerHTML = messages.map(msg => {
            // Support both 'type' (legacy) and 'role' (API) fields
            const isUser = (msg.type === 'user' || msg.role === 'user');
            return `
            <div class="flex gap-4 ${isUser ? 'flex-row-reverse' : ''}">
                <div class="w-8 h-8 rounded-full ${isUser ? 'bg-white/10' : 'bg-daena-gold'} flex-shrink-0 flex items-center justify-center ${isUser ? 'text-gray-400' : 'text-black'} font-bold mt-1">
                    ${isUser ? '<i class="fas fa-user"></i>' : 'D'}
                </div>
                <div class="flex-1 flex ${isUser ? 'justify-end' : ''}">
                    <div class="${isUser ? 'bg-blue-600' : 'bg-white/10'} rounded-2xl ${isUser ? 'rounded-tr-none' : 'rounded-tl-none'} px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                        <div class="whitespace-pre-wrap leading-relaxed">${isUser ? msg.content : formatMessage(msg.content)}</div>
                    </div>
                </div>
            </div>
        `}).join('');
        container.scrollTop = container.scrollHeight;
        updateScrollToBottomButton();
    }

    const chatFormEl = document.getElementById('chat-form');
    if (chatFormEl) chatFormEl.addEventListener('submit', async (e) => {
        e.preventDefault();
        const input = document.getElementById('message-input');
        const container = document.getElementById('chat-messages');
        if (!input || !container) return;
        const content = input.value.trim();

        if (!content) return;

        // Auto-interrupt previous stream if active
        if (streamAbortController) {
            streamAbortController.abort();
            streamAbortController = null;
            // Also notify backend to stop previous generation to free up resources
            if (currentSessionId) {
                fetch('/api/v1/daena/chat/stop', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: currentSessionId })
                }).catch(() => { });
            }
        }

        // Optimistic UI - show user message with edit button
        const msgId = 'msg-' + Date.now();
        container.insertAdjacentHTML('beforeend', `
            <div id="${msgId}" class="flex gap-4 flex-row-reverse group">
                <div class="w-8 h-8 rounded-full bg-white/10 flex-shrink-0 flex items-center justify-center text-gray-400 font-bold mt-1"><i class="fas fa-user"></i></div>
                <div class="flex-1 flex justify-end items-start gap-2">
                    <div class="flex gap-1 mt-2 opacity-70 group-hover:opacity-100">
                        <button type="button" onclick="editMessage('${msgId}', \`${content.replace(/`/g, '\\`').replace(/\\/g, '\\\\')}\`)" class="p-1.5 text-gray-500 hover:text-white hover:bg-white/10 rounded" title="Edit and resend">
                            <i class="fas fa-edit text-xs"></i>
                        </button>
                    </div>
                    <div class="bg-blue-600 rounded-2xl rounded-tr-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                        <p class="whitespace-pre-wrap leading-relaxed msg-content">${content}</p>
                    </div>
                </div>
            </div>
        `);
        input.value = '';
        container.scrollTop = container.scrollHeight;

        // Create streaming response container (pipeline status line stays; stream fills -text)
        const responseId = 'response-' + Date.now();
        const escapedPrompt = (content || '').replace(/\\/g, '\\\\').replace(/"/g, '&quot;').replace(/</g, '&lt;');
        container.insertAdjacentHTML('beforeend', `
            <div id="${responseId}" class="flex gap-4" data-prompt="${escapedPrompt}">
                <div class="w-8 h-8 rounded-full bg-daena-gold flex-shrink-0 flex items-center justify-center text-black font-bold mt-1">D</div>
                <div class="flex-1">
                    <div class="bg-white/10 rounded-2xl rounded-tl-none px-5 py-3 text-gray-200 inline-block max-w-[80%]">
                        <p id="${responseId}-pipeline" class="text-xs text-gray-500 mb-1 hidden"></p>
                        <div id="${responseId}-text" class="whitespace-pre-wrap leading-relaxed"><i class="fas fa-circle-notch fa-spin"></i></div>
                        <div id="${responseId}-sources" class="mt-2 pt-2 border-t border-white/10 hidden"></div>
                        <div id="${responseId}-actions" class="mt-2 flex gap-2 flex-wrap"></div>
                    </div>
                </div>
            </div>
        `);
        scrollChatToBottom(true);
        updateScrollToBottomButton();

        const controller = new AbortController();
        streamAbortController = controller;
        window._activeStreams = window._activeStreams || new Map();
        window._activeStreams.set(currentSessionId || 'default', controller);

        setStreamingUI(true);
        setStreamingBeforeUnload(true);

        try {
            // Trigger Think ‚Üí Plan ‚Üí Execute pipeline (every message runs the pipeline)
            try {
                // ... (pipeline logic)
            } catch (_) { }

            const payload = { message: content, session_id: currentSessionId };
            if (sendMode) payload.mode = sendMode;

            const response = await fetch('/api/v1/daena/chat/stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
                signal: controller.signal
            });

            sendMode = null;
            setSendMode(null);

            if (!response.ok) throw new Error('Stream request failed');

            // Handle the stream globally
            handleChatStream(currentSessionId || 'new', responseId, response);

        } catch (e) {
            if (e.name === 'AbortError') {
                window.showToast?.('Stopped', 'info');
            } else {
                console.error('Streaming chat error:', e);
                window.showToast?.('Failed to send message: ' + e.message, 'error');
            }
        } finally {
            // We don't setStreamingUI(false) here anymore, handleChatStream does it when 'done' received
        }
    });

    function startNewChat() {
        if (typeof createNewSession === 'function') {
            createNewSession();
        } else {
            // If checking availability, sometimes createNewSession is defined later.
            // But here it seems defined. 
            console.error("createNewSession not found");
        }
    }

    // Sidebar Resizing Logic
    document.addEventListener('DOMContentLoaded', () => {
        const sidebar = document.getElementById('sidebar-panel');
        const resizeHandle = document.getElementById('sidebar-resize-handle');

        if (sidebar && resizeHandle) {
            let isResizing = false;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                e.preventDefault(); // Prevent text selection
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                // Calculate new width
                // Sidebar is flex-shrink-0, constrained by min/max width in style
                let newWidth = e.clientX - sidebar.getBoundingClientRect().left;

                // Constraints (matches inline styles)
                if (newWidth < 200) newWidth = 200; // ~12rem
                if (newWidth > 640) newWidth = 640; // ~40rem

                sidebar.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = 'default';
                }
            });
        }

        // Auto-resume any streaming sessions from localStorage (background tasks)
        setTimeout(() => {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('daena_streaming_') && !key.includes('_id_')) {
                    const sid = key.replace('daena_streaming_', '');
                    const rid = localStorage.getItem(`daena_streaming_id_${sid}`);
                    // Only resume if not already in memory and not already resumed
                    if (!window._streamContexts.has(sid)) {
                        resumeStreaming(sid, rid);
                    }
                }
            }
        }, 300);
    });

    function showCategoryModal() {
        document.getElementById('category-modal').classList.remove('hidden');
    }

    function closeCategoryModal() {
        document.getElementById('category-modal').classList.add('hidden');
    }

    async function setCategory(category) {
        if (!currentSessionId) return;

        try {
            await window.api.setSessionCategory(currentSessionId, category);
            updateCategoryBadge(category);
            await loadSessions();
            closeCategoryModal();
            window.showToast(`Category set to ${category}`, 'success');
        } catch (e) {
            window.showToast('Failed to update category', 'error');
        }
    }

    function clearContext() {
        if (!currentSessionId) {
            window.showToast?.('No active chat to clear', 'warning');
            return;
        }
        showModal(
            'üßπ Clear Context',
            'Clear conversation context? This resets Daena\'s memory of this conversation but keeps the messages visible.',
            'Clear Context',
            false,
            '',
            async () => {
                try {
                    await window.api.clearSessionContext(currentSessionId);
                    window.showToast?.('Context cleared - Daena will treat this as a fresh conversation', 'success');
                } catch (e) {
                    // Fallback: just show success (context clearing is a client-side concept too)
                    window.showToast?.('Context cleared', 'info');
                }
            }
        );
    }

    // Keyboard shortcuts: Escape closes modals, Delete deletes current session
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeCategoryModal();
            closeModal();
        }
        // Delete key to delete current session (when not in input field)
        if (e.key === 'Delete' && currentSessionId) {
            const activeElement = document.activeElement;
            const isInput = activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.isContentEditable;
            if (!isInput) {
                deleteSession(currentSessionId);
            }
        }
    });

    // Voice Toggle Function (sync with backend GET/POST /api/v1/voice/status, /api/v1/voice/talk-mode)
    let voiceEnabled = false;
    async function toggleVoice() {
        try {
            voiceEnabled = !voiceEnabled;
            const data = await window.api.setTalkMode(voiceEnabled);
            voiceEnabled = data.talk_active !== undefined ? data.talk_active : voiceEnabled;

            const icon = document.getElementById('voice-icon');
            if (voiceEnabled) {
                icon.className = 'fas fa-microphone text-green-400';
                window.showToast('Voice enabled - Daena will speak', 'success');
            } else {
                icon.className = 'fas fa-microphone-slash';
                window.showToast('Voice disabled', 'info');
            }
        } catch (e) {
            console.error('Voice toggle error:', e);
            window.showToast('Failed to toggle voice: ' + e.message, 'error');
        }
    }

    // Edit Message Function - ChatGPT-style: edit and resend for new answer
    function editMessage(msgId, originalContent) {
        const msgEl = document.getElementById(msgId);
        if (!msgEl) return;

        const input = document.getElementById('message-input');
        if (input) {
            input.value = originalContent;
            input.focus();
            input.select();
        }

        // Remove this message and all subsequent messages (assistant reply)
        let nextEl = msgEl.nextElementSibling;
        while (nextEl) {
            const toRemove = nextEl;
            nextEl = nextEl.nextElementSibling;
            toRemove.remove();
        }
        msgEl.remove();

        window.showToast?.('Edit your message and click Send to get a new response', 'info');
    }

    // Regenerate: remove this reply and the previous user message, fill input so user can Send for new answer
    function regenerateResponse(responseId) {
        const div = document.getElementById(responseId);
        if (!div) return;
        const rawPrompt = div.getAttribute('data-prompt');
        if (!rawPrompt) return;
        const prompt = (rawPrompt || '')
            .replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
        div.remove();
        const prev = div.previousElementSibling;
        if (prev) prev.remove();
        const input = document.getElementById('message-input');
        if (input) {
            input.value = prompt;
            input.focus();
        }
        window.showToast?.('Click Send to get a new response', 'info');
    }

    window.editMessage = editMessage;
    window.regenerateResponse = regenerateResponse;

    // Initialize voice status
    (async function initVoiceStatus() {
        try {
            const status = await window.api.request('/voice/status');
            voiceEnabled = status.talk_active || false;
            const icon = document.getElementById('voice-icon');
            if (voiceEnabled) {
                icon.className = 'fas fa-microphone text-green-400';
            }
        } catch (e) {
            console.log('Voice status check:', e);
        }
    })();

    // Export chat
    async function exportChat(format = 'json') {
        if (!currentSessionId) {
            window.showToast?.('No chat session to export', 'warning');
            return;
        }

        try {
            const data = await window.api.getChatHistory(currentSessionId);
            const messages = data.messages || data.session?.messages || [];
            const sessionInfo = data.session || {};

            let content, filename, mimeType;

            if (format === 'json') {
                content = JSON.stringify({
                    session_id: currentSessionId,
                    title: sessionInfo.title || 'Daena Chat',
                    category: sessionInfo.category || 'general',
                    exported_at: new Date().toISOString(),
                    messages: messages
                }, null, 2);
                filename = `daena-chat-${currentSessionId.slice(0, 8)}.json`;
                mimeType = 'application/json';
            } else {
                // TXT format
                const lines = [
                    `Daena Chat Export`,
                    `Session: ${sessionInfo.title || 'Untitled'}`,
                    `Date: ${new Date().toLocaleDateString()}`,
                    `${'='.repeat(50)}`,
                    ''
                ];
                for (const msg of messages) {
                    const role = msg.role || msg.type || 'unknown';
                    const sender = role === 'user' ? 'You' : 'Daena';
                    lines.push(`[${sender}]`);
                    lines.push(msg.content);
                    lines.push('');
                }
                content = lines.join('\\n');
                filename = `daena-chat-${currentSessionId.slice(0, 8)}.txt`;
                mimeType = 'text/plain';
            }

            // Download file
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            window.showToast?.(`Chat exported as ${format.toUpperCase()}`, 'success');
        } catch (e) {
            console.error('Export error:', e);
            window.showToast?.('Failed to export chat', 'error');
        }
    }

    // Share chat (copy link)
    async function shareChat() {
        if (!currentSessionId) {
            window.showToast?.('No chat session to share', 'warning');
            return;
        }

        const shareUrl = `${window.location.origin}/ui/daena-office?session=${currentSessionId}`;

        try {
            await navigator.clipboard.writeText(shareUrl);
            window.showToast?.('Share link copied to clipboard!', 'success');
        } catch (e) {
            // Fallback for browsers without clipboard API
            const textarea = document.createElement('textarea');
            textarea.value = shareUrl;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            window.showToast?.('Share link copied!', 'success');
        }
    }

    // === Tool Console Functions ===

    let toolConsoleVisible = false;

    function toggleToolConsole() {
        const console = document.getElementById('tool-console');
        const btn = document.getElementById('tool-console-btn');
        toolConsoleVisible = !toolConsoleVisible;

        if (toolConsoleVisible) {
            console.style.display = 'flex';
            btn?.classList.add('text-daena-gold');
            btn?.classList.remove('text-gray-400');
            // Load MCP status
            loadMcpStatus();
        } else {
            console.style.display = 'none';
            btn?.classList.remove('text-daena-gold');
            btn?.classList.add('text-gray-400');
        }
    }

    async function executeQuickTool(command) {
        const output = document.getElementById('tool-output');
        output.innerHTML = `<span class="text-gray-500">Running: ${command}...</span>`;

        try {
            const result = await window.api.executeDaenaCommand(command);
            if (result.success || result.result?.success) {
                const data = result.result || result;
                output.innerHTML = `<span class="text-green-400">‚úì Success</span>\n\n${JSON.stringify(data, null, 2).substring(0, 2000)}`;
            } else {
                output.innerHTML = `<span class="text-red-400">‚úó Error:</span> ${result.error || JSON.stringify(result)}`;
            }
        } catch (e) {
            output.innerHTML = `<span class="text-red-400">‚úó Error:</span> ${e.message}`;
        }
    }

    async function executeToolCommand(event) {
        event.preventDefault();
        const input = document.getElementById('tool-command');
        const command = input.value.trim();
        if (!command) return;

        await executeQuickTool(command);
        input.value = '';
    }

    function showDesktopClickForm() {
        document.getElementById('desktop-type-form').classList.add('hidden');
        const el = document.getElementById('desktop-click-form');
        el.classList.toggle('hidden');
        if (!el.classList.contains('hidden')) {
            document.getElementById('desktop-x').focus();
        }
    }

    function showDesktopTypeForm() {
        document.getElementById('desktop-click-form').classList.add('hidden');
        const el = document.getElementById('desktop-type-form');
        el.classList.toggle('hidden');
        if (!el.classList.contains('hidden')) {
            document.getElementById('desktop-type-text').focus();
        }
    }

    async function runDesktopClick() {
        const x = document.getElementById('desktop-x').value.trim();
        const y = document.getElementById('desktop-y').value.trim();
        if (!x || !y) {
            const output = document.getElementById('tool-output');
            output.innerHTML = '<span class="text-amber-400">Enter X and Y (e.g. 100, 200).</span>';
            return;
        }
        await executeQuickTool('click at ' + x + ' ' + y);
    }

    async function runDesktopType() {
        const text = document.getElementById('desktop-type-text').value.trim();
        if (!text) {
            const output = document.getElementById('tool-output');
            output.innerHTML = '<span class="text-amber-400">Enter text to type on desktop.</span>';
            return;
        }
        await executeQuickTool('type on desktop ' + text);
    }

    async function discoverMcpServers() {
        const output = document.getElementById('tool-output');
        output.innerHTML = '<span class="text-gray-500">Discovering MCP servers...</span>';

        try {
            const result = await window.api.discoverMcpServers();
            if (result.success) {
                const servers = result.servers || [];
                let html = '<span class="text-green-400">üîå MCP Servers Found:</span>\n\n';
                servers.forEach(s => {
                    const status = s.available ? '‚úÖ' : '‚ùå';
                    html += `${status} ${s.name} (${s.url})\n`;
                    if (s.capabilities) {
                        html += `   Capabilities: ${s.capabilities.join(', ')}\n`;
                    }
                });
                output.innerHTML = html;
                loadMcpStatus();
            } else {
                output.innerHTML = `<span class="text-red-400">‚úó Error:</span> ${result.error}`;
            }
        } catch (e) {
            output.innerHTML = `<span class="text-red-400">‚úó Error:</span> ${e.message}`;
        }
    }

    async function loadMcpStatus() {
        const statusEl = document.getElementById('mcp-status');
        try {
            const result = await window.api.listMcpConnections();
            const connections = result.connections || [];
            if (connections.length === 0) {
                statusEl.innerHTML = '<span class="text-gray-500">No active connections</span>';
            } else {
                statusEl.innerHTML = connections.map(c =>
                    `<span class="text-green-400">‚óè</span> ${c.name}`
                ).join('<br>');
            }
        } catch (e) {
            statusEl.innerHTML = '<span class="text-gray-500">Unable to check</span>';
        }
    }

    // --- Voice Settings Functions ---
    async function openVoiceSettings() {
        // Create modal if it doesn't exist
        let modal = document.getElementById('voice-settings-modal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'voice-settings-modal';
            modal.className = 'fixed inset-0 bg-black/80 backdrop-blur-sm hidden items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-gray-900 border border-white/10 rounded-xl w-[400px] shadow-2xl">
                    <div class="p-4 border-b border-white/10 flex justify-between items-center">
                        <h3 class="text-lg font-medium text-white">Voice Settings</h3>
                        <button onclick="closeVoiceSettings()" class="text-gray-400 hover:text-white">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <div class="p-6 space-y-6">
                        <div class="space-y-2">
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Volume</span>
                                <span class="text-daena-gold" id="volume-value">80%</span>
                            </div>
                            <input type="range" min="0" max="100" value="80" class="w-full accent-daena-gold bg-white/10 rounded-lg h-2 cursor-pointer" id="voice-volume" oninput="document.getElementById('volume-value').innerText = this.value + '%'">
                        </div>
                        <div class="space-y-2">
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Speed (WPM)</span>
                                <span class="text-daena-gold" id="rate-value">150</span>
                            </div>
                            <input type="range" min="50" max="400" value="150" class="w-full accent-daena-gold bg-white/10 rounded-lg h-2 cursor-pointer" id="voice-rate" oninput="document.getElementById('rate-value').innerText = this.value">
                        </div>
                        <div class="space-y-2">
                            <div class="flex justify-between text-sm">
                                <span class="text-gray-400">Pitch</span>
                                <span class="text-daena-gold" id="pitch-value">100</span>
                            </div>
                            <input type="range" min="50" max="200" value="100" class="w-full accent-daena-gold bg-white/10 rounded-lg h-2 cursor-pointer" id="voice-pitch" oninput="document.getElementById('pitch-value').innerText = this.value">
                        </div>
                        <button onclick="testVoiceSettings()" class="w-full py-2 bg-white/5 hover:bg-white/10 border border-white/10 rounded-lg text-sm text-gray-300 transition-colors flex items-center justify-center gap-2">
                            <i class="fas fa-play"></i> Test Voice
                        </button>
                    </div>
                    <div class="p-4 border-t border-white/10 flex justify-end gap-3">
                        <button onclick="closeVoiceSettings()" class="px-4 py-2 text-sm text-gray-400 hover:text-white transition-colors">Cancel</button>
                        <button onclick="saveVoiceSettings()" class="px-4 py-2 text-sm bg-daena-gold hover:bg-yellow-500 text-black font-medium rounded-lg transition-colors">Save</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Load current settings
        try {
            const response = await fetch('/api/v1/voice/settings');
            const settings = await response.json();
            if (settings) {
                document.getElementById('voice-volume').value = (settings.volume * 100) || 80;
                document.getElementById('voice-rate').value = settings.rate || 150;
                document.getElementById('voice-pitch').value = settings.pitch || 100;
                document.getElementById('volume-value').innerText = document.getElementById('voice-volume').value + '%';
                document.getElementById('rate-value').innerText = document.getElementById('voice-rate').value;
                document.getElementById('pitch-value').innerText = document.getElementById('voice-pitch').value;
            }
        } catch (e) {
            console.error("Failed to load voice settings:", e);
        }

        modal.classList.remove('hidden');
        modal.classList.add('flex');
    }

    function closeVoiceSettings() {
        const modal = document.getElementById('voice-settings-modal');
        if (modal) {
            modal.classList.add('hidden');
            modal.classList.remove('flex');
        }
    }

    async function saveVoiceSettings() {
        const volume = document.getElementById('voice-volume').value / 100;
        const rate = parseInt(document.getElementById('voice-rate').value);
        const pitch = parseInt(document.getElementById('voice-pitch').value);

        try {
            await fetch('/api/v1/voice/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ volume, rate, pitch })
            });
            closeVoiceSettings();
        } catch (e) {
            console.error("Failed to save settings:", e);
            alert("Failed to save settings");
        }
    }

    async function testVoiceSettings() {
        await saveVoiceSettings();
        try {
            await fetch('/api/v1/voice/test');
        } catch (e) {
            console.error("Test failed:", e);
        }
    }

    // --- Input Persistence ---
    (function () {
        const input = document.getElementById('message-input');
        if (input) {
            // Restore draft
            const draft = localStorage.getItem('daena_draft_message');
            if (draft) input.value = draft;

            // Save on input
            input.addEventListener('input', (e) => {
                localStorage.setItem('daena_draft_message', e.target.value);
            });

            // Clear on Enter
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    setTimeout(() => localStorage.removeItem('daena_draft_message'), 100);
                }
            });
        }
    })();
</script>
{% endblock %}