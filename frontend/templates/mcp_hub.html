{% extends "base.html" %}

{% block title %}MCP Hub - Visual Connections{% endblock %}

{% block head %}
<style>
    /* n8n-style Canvas */
    .mcp-canvas {
        position: relative;
        width: 100%;
        height: calc(100vh - 120px);
        background:
            linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
        background-size: 20px 20px;
        overflow: hidden;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* SVG Connection Lines */
    .connections-svg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }

    .connection-line {
        stroke: var(--daena-gold);
        stroke-width: 2;
        fill: none;
        stroke-dasharray: 5, 5;
        animation: flowDash 1s linear infinite;
    }

    .connection-line.active {
        stroke-dasharray: none;
        stroke-width: 3;
        filter: drop-shadow(0 0 6px var(--daena-gold));
    }

    @keyframes flowDash {
        to {
            stroke-dashoffset: -10;
        }
    }

    /* Node Styles */
    .mcp-node {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        min-width: 180px;
        cursor: move;
        user-select: none;
        z-index: 10;
        transition: box-shadow 0.3s ease, border-color 0.3s ease;
    }

    .mcp-node:hover {
        border-color: var(--daena-gold);
        box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
    }

    .mcp-node.selected {
        border-color: var(--daena-gold);
        box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
    }

    .mcp-node.connected {
        border-color: #22c55e;
    }

    .mcp-node.offline {
        border-color: #ef4444;
        opacity: 0.7;
    }

    .node-header {
        padding: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .node-icon {
        width: 36px;
        height: 36px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
    }

    .node-title {
        font-weight: 700;
        color: white;
        font-size: 14px;
    }

    .node-status {
        font-size: 11px;
        color: #9CA3AF;
    }

    .node-body {
        padding: 12px;
    }

    .node-stat {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #9CA3AF;
        margin-bottom: 6px;
    }

    .node-stat-value {
        color: white;
        font-weight: 600;
    }

    .node-actions {
        padding: 8px 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        gap: 6px;
    }

    .node-btn {
        flex: 1;
        padding: 6px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .node-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .node-btn.primary {
        background: var(--daena-gold);
        color: black;
        border-color: var(--daena-gold);
    }

    /* Connection Ports */
    .node-port {
        position: absolute;
        width: 12px;
        height: 12px;
        background: #1f2937;
        border: 2px solid #6b7280;
        border-radius: 50%;
        cursor: crosshair;
        z-index: 20;
    }

    .node-port.input {
        left: -6px;
        top: 50%;
        transform: translateY(-50%);
    }

    .node-port.output {
        right: -6px;
        top: 50%;
        transform: translateY(-50%);
    }

    .node-port.connected {
        background: #22c55e;
        border-color: #22c55e;
    }

    .node-port:hover {
        border-color: var(--daena-gold);
        transform: translateY(-50%) scale(1.2);
    }

    /* Sidebar Panel */
    .mcp-sidebar {
        position: fixed;
        right: 0;
        top: 64px;
        width: 320px;
        height: calc(100vh - 64px);
        background: rgba(0, 0, 0, 0.9);
        border-left: 1px solid rgba(255, 255, 255, 0.1);
        padding: 20px;
        overflow-y: auto;
        z-index: 100;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }

    .mcp-sidebar.open {
        transform: translateX(0);
    }

    /* Toolbar */
    .mcp-toolbar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 16px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 12px;
        margin-bottom: 16px;
    }

    .toolbar-btn {
        padding: 8px 12px;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        font-size: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s;
    }

    .toolbar-btn:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .toolbar-btn.active {
        background: var(--daena-gold);
        color: black;
        border-color: var(--daena-gold);
    }

    /* Mini-map */
    .minimap {
        position: absolute;
        bottom: 16px;
        right: 16px;
        width: 160px;
        height: 100px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        overflow: hidden;
    }

    /* Log Panel */
    .log-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 150px;
        background: rgba(0, 0, 0, 0.95);
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        font-family: 'Fira Code', monospace;
        font-size: 12px;
        overflow-y: auto;
        padding: 12px;
        transform: translateY(100%);
        transition: transform 0.3s ease;
    }

    .log-panel.open {
        transform: translateY(0);
    }
</style>
{% endblock %}

{% block content %}
<div class="min-h-screen bg-gradient-to-br from-gray-900 via-black to-gray-900 p-4">
    <!-- Header -->
    <div class="flex items-center justify-between mb-4">
        <div class="flex items-center gap-4">
            <div
                class="w-10 h-10 rounded-xl bg-gradient-to-br from-purple-500 to-blue-500 flex items-center justify-center">
                <i class="fas fa-project-diagram text-white"></i>
            </div>
            <div>
                <h1 class="text-2xl font-bold text-white">MCP Hub</h1>
                <p class="text-sm text-gray-400">Visual Connection Canvas</p>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="mcp-toolbar">
            <button class="toolbar-btn active" onclick="discoverNodes()">
                <i class="fas fa-search"></i> Discover
            </button>
            <button class="toolbar-btn" onclick="autoLayout()">
                <i class="fas fa-sitemap"></i> Auto Layout
            </button>
            <button class="toolbar-btn" onclick="toggleLog()">
                <i class="fas fa-terminal"></i> Log
            </button>
            <button class="toolbar-btn" onclick="refreshAll()">
                <i class="fas fa-sync-alt"></i> Refresh
            </button>
        </div>
    </div>

    <!-- Canvas -->
    <div class="mcp-canvas" id="canvas">
        <!-- SVG for connection lines -->
        <svg class="connections-svg" id="connections-svg"></svg>

        <!-- Nodes will be dynamically added here -->

        <!-- Central Daena Node (always visible) -->
        <div class="mcp-node selected" id="node-daena" style="left: 50%; top: 50%; transform: translate(-50%, -50%);"
            data-node-id="daena" data-x="50" data-y="50">
            <div class="node-port input connected"></div>
            <div class="node-port output connected"></div>
            <div class="node-header">
                <div class="node-icon" style="background: linear-gradient(135deg, #d4af37, #f5d000);">
                    <i class="fas fa-crown text-black"></i>
                </div>
                <div>
                    <div class="node-title">Daena VP</div>
                    <div class="node-status" id="daena-status">‚óè Central AI Hub</div>
                </div>
            </div>
            <div class="node-body">
                <div class="node-stat">
                    <span>Brain Status</span>
                    <span class="node-stat-value" id="brain-connection-status">Checking...</span>
                </div>
                <div class="node-stat">
                    <span>Active Model</span>
                    <span class="node-stat-value" id="active-model-name">-</span>
                </div>
                <div class="node-stat">
                    <span>Connections</span>
                    <span class="node-stat-value" id="total-connections">0</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Log Panel -->
    <div class="log-panel" id="log-panel">
        <div class="flex items-center justify-between mb-2">
            <span class="text-white font-bold">Connection Log</span>
            <button onclick="clearLog()" class="text-gray-400 hover:text-white text-sm">Clear</button>
        </div>
        <div id="log-content" class="space-y-1 text-gray-400">
            <div>Ready to connect...</div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Node configurations
    const NODES = {
        daena: { id: 'daena', type: 'central', x: 50, y: 50, connections: [] },
        ollama: {
            id: 'ollama',
            type: 'brain',
            name: 'Ollama (Brain)',
            icon: 'fa-brain',
            color: '#10B981',
            url: 'http://localhost:11434',
            x: 20, y: 30
        },
        departments: {
            id: 'departments',
            type: 'group',
            name: 'Departments',
            icon: 'fa-building',
            color: '#3B82F6',
            count: 8,
            x: 80, y: 30
        },
        agents: {
            id: 'agents',
            type: 'group',
            name: 'Agents',
            icon: 'fa-robot',
            color: '#8B5CF6',
            count: 48,
            x: 80, y: 70
        },
        councils: {
            id: 'councils',
            type: 'group',
            name: 'Councils',
            icon: 'fa-users-cog',
            color: '#F59E0B',
            count: 4,
            x: 20, y: 70
        },
        browser_mcp: {
            id: 'browser_mcp',
            type: 'mcp',
            name: 'Browser MCP',
            icon: 'fa-globe',
            color: '#06B6D4',
            url: 'http://localhost:3001',
            x: 10, y: 50
        },
        git_mcp: {
            id: 'git_mcp',
            type: 'mcp',
            name: 'Git MCP',
            icon: 'fa-code-branch',
            color: '#EC4899',
            url: 'http://localhost:3002',
            x: 90, y: 50
        },
        mobile_agent: {
            id: 'mobile_agent',
            type: 'mcp',
            name: 'Mobile Agent',
            icon: 'fa-mobile-alt',
            color: '#F97316',
            url: 'http://localhost:3003',
            x: 50, y: 85
        }
    };

    let connections = [];
    let selectedNode = null;
    let draggedNode = null;
    let logVisible = false;

    document.addEventListener('DOMContentLoaded', async () => {
        await discoverNodes();
        initDragAndDrop();
    });

    async function discoverNodes() {
        addLog('üîç Discovering nodes...');

        // Check brain status
        try {
            const brainRes = await fetch('/api/v1/brain/status');
            const brainData = await brainRes.json();

            document.getElementById('brain-connection-status').textContent =
                brainData.connected ? 'üü¢ Connected' : 'üî¥ Offline';
            document.getElementById('active-model-name').textContent =
                brainData.active_model || brainData.models?.[0]?.name || 'None';

            NODES.ollama.connected = brainData.ollama_available;

            if (brainData.connected) {
                addLog('‚úÖ Brain connected: ' + (brainData.active_model || 'qwen2.5'));
            } else {
                addLog('‚ö†Ô∏è Brain offline - Start Ollama');
            }
        } catch (e) {
            addLog('‚ùå Failed to check brain: ' + e.message);
        }

        // Load departments
        try {
            const deptRes = await fetch('/api/v1/departments/');
            const deptData = await deptRes.json();
            NODES.departments.count = deptData.length || 8;
            NODES.departments.connected = true;
            addLog(`‚úÖ Departments loaded: ${NODES.departments.count}`);
        } catch (e) {
            addLog('‚ö†Ô∏è Departments: Using defaults');
        }

        // Load councils
        try {
            const councilRes = await fetch('/api/v1/council/list');
            const councilData = await councilRes.json();
            NODES.councils.count = councilData.length || 4;
            NODES.councils.connected = true;
            addLog(`‚úÖ Councils loaded: ${NODES.councils.count}`);
        } catch (e) {
            addLog('‚ö†Ô∏è Councils: Using defaults');
        }

        // Load agents
        try {
            const agentRes = await fetch('/api/v1/agents/');
            const agentData = await agentRes.json();
            const agents = agentData.agents || agentData || [];
            NODES.agents.count = agents.length || 48;
            NODES.agents.connected = true;
            addLog(`‚úÖ Agents loaded: ${NODES.agents.count}`);
        } catch (e) {
            addLog('‚ö†Ô∏è Agents: Using defaults');
        }

        // Render all nodes
        renderNodes();
        renderConnections();
        updateConnectionCount();
    }

    function renderNodes() {
        const canvas = document.getElementById('canvas');

        Object.values(NODES).forEach(node => {
            if (node.id === 'daena') return; // Central node already exists

            // Remove existing node if any
            const existing = document.getElementById(`node-${node.id}`);
            if (existing) existing.remove();

            const nodeEl = document.createElement('div');
            nodeEl.className = `mcp-node ${node.connected ? 'connected' : 'offline'}`;
            nodeEl.id = `node-${node.id}`;
            nodeEl.dataset.nodeId = node.id;
            nodeEl.style.left = `${node.x}%`;
            nodeEl.style.top = `${node.y}%`;
            nodeEl.style.transform = 'translate(-50%, -50%)';

            const countDisplay = node.count ? `
                <div class="node-stat">
                    <span>Count</span>
                    <span class="node-stat-value">${node.count}</span>
                </div>
            ` : '';

            nodeEl.innerHTML = `
                <div class="node-port input ${node.connected ? 'connected' : ''}"></div>
                <div class="node-port output ${node.connected ? 'connected' : ''}"></div>
                <div class="node-header">
                    <div class="node-icon" style="background: ${node.color}33;">
                        <i class="fas ${node.icon}" style="color: ${node.color}"></i>
                    </div>
                    <div>
                        <div class="node-title">${node.name}</div>
                        <div class="node-status">${node.connected ? '‚óè Connected' : '‚óã Offline'}</div>
                    </div>
                </div>
                <div class="node-body">
                    ${countDisplay}
                    <div class="node-stat">
                        <span>Status</span>
                        <span class="node-stat-value" style="color: ${node.connected ? '#22c55e' : '#ef4444'}">
                            ${node.connected ? 'Active' : 'Inactive'}
                        </span>
                    </div>
                </div>
                <div class="node-actions">
                    <button class="node-btn" onclick="testNode('${node.id}')">
                        <i class="fas fa-vial"></i> Test
                    </button>
                    <button class="node-btn primary" onclick="connectNode('${node.id}')">
                        <i class="fas fa-plug"></i> Connect
                    </button>
                </div>
            `;

            canvas.appendChild(nodeEl);

            // Add connection if node is connected
            if (node.connected) {
                connections.push({ from: node.id, to: 'daena' });
            }
        });
    }

    function renderConnections() {
        const svg = document.getElementById('connections-svg');
        svg.innerHTML = '';

        connections.forEach(conn => {
            const fromEl = document.getElementById(`node-${conn.from}`);
            const toEl = document.getElementById(`node-${conn.to}`);

            if (!fromEl || !toEl) return;

            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const canvas = document.getElementById('canvas');
            const canvasRect = canvas.getBoundingClientRect();

            // Calculate center points
            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
            const y2 = toRect.top + toRect.height / 2 - canvasRect.top;

            // Create curved path
            const midX = (x1 + x2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`);
            path.setAttribute('class', 'connection-line active');
            svg.appendChild(path);
        });
    }

    function initDragAndDrop() {
        const canvas = document.getElementById('canvas');

        canvas.addEventListener('mousedown', (e) => {
            const node = e.target.closest('.mcp-node');
            if (!node) return;

            draggedNode = node;
            node.classList.add('selected');
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!draggedNode) return;

            const canvasRect = canvas.getBoundingClientRect();
            const x = ((e.clientX - canvasRect.left) / canvasRect.width) * 100;
            const y = ((e.clientY - canvasRect.top) / canvasRect.height) * 100;

            draggedNode.style.left = `${Math.max(5, Math.min(95, x))}%`;
            draggedNode.style.top = `${Math.max(5, Math.min(95, y))}%`;

            // Re-render connections
            renderConnections();
        });

        canvas.addEventListener('mouseup', () => {
            if (draggedNode) {
                draggedNode.classList.remove('selected');
                draggedNode = null;
            }
        });
    }

    async function testNode(nodeId) {
        addLog(`üîÑ Testing ${nodeId}...`);

        try {
            let response;
            if (nodeId === 'ollama') {
                response = await fetch('/api/v1/brain/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_name: 'qwen2.5:7b-instruct' })
                });
            } else {
                response = await fetch(`/api/v1/${nodeId.replace('_', '-')}/`);
            }

            if (response.ok) {
                addLog(`‚úÖ ${nodeId} test passed`);
                window.showToast?.(`${nodeId} is working!`, 'success');
            } else {
                addLog(`‚ö†Ô∏è ${nodeId} test returned error`);
            }
        } catch (e) {
            addLog(`‚ùå ${nodeId} test failed: ${e.message}`);
            window.showToast?.(`${nodeId} test failed`, 'error');
        }
    }

    async function connectNode(nodeId) {
        const node = NODES[nodeId];
        if (!node) return;

        addLog(`üîå Connecting ${node.name}...`);

        // Add visual connection
        node.connected = true;
        connections = connections.filter(c => c.from !== nodeId);
        connections.push({ from: nodeId, to: 'daena' });

        // Update UI
        const nodeEl = document.getElementById(`node-${nodeId}`);
        if (nodeEl) {
            nodeEl.classList.remove('offline');
            nodeEl.classList.add('connected');
        }

        renderConnections();
        updateConnectionCount();

        addLog(`‚úÖ ${node.name} connected`);
        window.showToast?.(`${node.name} connected`, 'success');
    }

    function updateConnectionCount() {
        const count = connections.length;
        document.getElementById('total-connections').textContent = count;
    }

    function autoLayout() {
        // Reset nodes to default positions
        Object.values(NODES).forEach(node => {
            const nodeEl = document.getElementById(`node-${node.id}`);
            if (nodeEl) {
                nodeEl.style.left = `${node.x}%`;
                nodeEl.style.top = `${node.y}%`;
            }
        });
        renderConnections();
        addLog('üìê Auto layout applied');
    }

    function toggleLog() {
        logVisible = !logVisible;
        document.getElementById('log-panel').classList.toggle('open', logVisible);
    }

    function addLog(message) {
        const logContent = document.getElementById('log-content');
        const time = new Date().toLocaleTimeString();
        logContent.innerHTML = `<div><span class="text-gray-600">[${time}]</span> ${message}</div>` + logContent.innerHTML;
    }

    function clearLog() {
        document.getElementById('log-content').innerHTML = '<div>Log cleared</div>';
    }

    async function refreshAll() {
        await discoverNodes();
        window.showToast?.('Refreshed', 'success');
    }
</script>
{% endblock %}